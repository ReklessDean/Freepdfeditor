<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro PDF Editor Suite</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@0.0.4/dist/fontkit.umd.min.js"></script>
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        body { font-family: 'Inter', sans-serif; background-color: #1e1e1e; overflow: hidden; }
        
        /* Layout Grid */
        #app-container {
            display: grid;
            grid-template-rows: 60px 40px 1fr;
            height: 100vh;
        }

        /* Workspace */
        #pdf-workspace {
            overflow: auto;
            background-color: #525659;
            position: relative;
            height: 100%;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pdf-page-container {
            position: relative;
            margin-bottom: 30px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            background: white;
            transform-origin: top left;
        }

        /* Overlay & Elements */
        .page-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: all; 
            overflow: hidden;
            z-index: 10;
        }

        /* Custom Elements Common */
        .editor-element {
            position: absolute;
            z-index: 20;
            user-select: none; 
            box-sizing: border-box;
            touch-action: none; 
            min-width: 10px;
            min-height: 10px;
        }
        .editor-element:hover { outline: 1px dashed #3b82f6; }
        
        /* Selected State */
        .editor-element.selected { 
            outline: 2px solid #2563eb; 
            z-index: 50;
            cursor: move; 
        }
        
        /* Specific Elements */
        .added-text {
            font-family: Helvetica, sans-serif; 
            color: #000;
            line-height: 1.2;
            padding: 6px; 
            white-space: normal; 
            word-break: break-word; 
            overflow: hidden; 
            cursor: default;
            background: transparent;
        }
        
        .added-text:hover {
            background-color: rgba(59, 130, 246, 0.05); 
        }
        
        /* Editing State */
        .added-text.selected.is-editing {
            outline: 2px solid #ef4444; 
            cursor: text !important; 
            user-select: text !important; 
            -webkit-user-select: text !important;
        }

        /* Magic Text Highlight */
        .magic-highlight {
            position: absolute;
            background-color: rgba(59, 130, 246, 0.2);
            border: 1px solid #3b82f6;
            cursor: pointer;
            z-index: 5;
            pointer-events: none; 
        }
        
        /* Resizing Handles */
        .resize-handle {
            position: absolute;
            z-index: 100;
            touch-action: none;
            display: none; 
            width: 10px;
            height: 10px;
            background-color: #3b82f6;
            border: 1px solid white;
            border-radius: 50%;
        }
        .editor-element.selected .resize-handle {
            display: block;
        }

        .shape-box { border: 2px solid #000; background: transparent; }
        .shape-line { background-color: #000; }
        .whiteout-box { background-color: white; border: none; } 
        
        /* Guides */
        .guide-line {
            background-color: #06b6d4; 
            pointer-events: all;
            z-index: 100;
            border: none !important; 
            outline: none !important;
            opacity: 0.8;
            transition: background-color 0.1s;
        }
        .guide-line.selected {
            background-color: #ef4444; 
        }

        .guide-horizontal {
            height: 1px;
            width: 100%;
            left: 0;
            cursor: ns-resize;
        }
        .guide-vertical {
            width: 1px;
            height: 100%;
            top: 0;
            cursor: ew-resize;
        }

        /* Tools Active State */
        .tool-btn { position: relative; }
        .tool-btn.active {
            background-color: #e0f2fe;
            color: #0284c7;
            border-color: #0284c7;
        }

        /* Tabs & Loader styles */
        .tab-item { user-select: none; max-width: 200px; }
        .tab-item.active { background-color: #525659; color: white; border-bottom: 2px solid #60a5fa; }
        .dropdown-menu { display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #e5e5e5; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); border-radius: 6px; z-index: 100; min-width: 150px; padding: 4px; }
        .dropdown-menu.show { display: block; }
        .loader { border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #3498db; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="app-container">
        
        <!-- Header / Toolbar -->
        <header class="bg-white border-b border-gray-200 flex items-center justify-between px-4 z-50 shadow-sm">
            <div class="flex items-center gap-4">
                <div class="flex items-center gap-2 text-gray-700 font-bold text-lg select-none">
                    <div class="bg-red-600 text-white p-1 rounded-md text-sm"><i class="fa-solid fa-file-pdf"></i></div>
                    <span class="hidden md:inline">PDF Studio</span>
                </div>
                
                <div class="h-6 w-px bg-gray-300 mx-2"></div>
                
                <!-- History Tools -->
                <div class="flex items-center gap-1">
                    <button onclick="performUndo()" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Undo (Ctrl+Z)">
                        <i class="fa-solid fa-rotate-left"></i>
                    </button>
                    <button onclick="performRedo()" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Redo (Ctrl+Y)">
                        <i class="fa-solid fa-rotate-right"></i>
                    </button>
                </div>

                <div class="h-6 w-px bg-gray-300 mx-2"></div>

                <!-- Main Tools -->
                <div id="main-tools" class="flex items-center gap-1">
                    <button onclick="setTool('cursor')" id="btn-cursor" class="tool-btn active p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Select / Move / Resize">
                        <i class="fa-solid fa-arrow-pointer"></i>
                    </button>
                    
                    <button onclick="setTool('text')" id="btn-text" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Draw Text Box">
                        <i class="fa-solid fa-font"></i>
                    </button>
                    
                    <!-- Guides Dropdown -->
                    <div class="relative">
                        <button onclick="toggleDropdown('guides-menu')" id="btn-guide" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition flex items-center gap-1" title="Insert Guide">
                            <i class="fa-solid fa-ruler-combined"></i> <i class="fa-solid fa-caret-down text-xs"></i>
                        </button>
                        <div id="guides-menu" class="dropdown-menu">
                            <div onclick="setTool('guide-h')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-ruler-horizontal"></i> H. Guide
                            </div>
                            <div onclick="setTool('guide-v')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-ruler-vertical"></i> V. Guide
                            </div>
                        </div>
                    </div>

                    <button onclick="setTool('whiteout')" id="btn-whiteout" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Whiteout / Eraser">
                        <i class="fa-solid fa-eraser"></i>
                    </button>

                    <!-- Shapes Dropdown -->
                    <div class="relative">
                        <button onclick="toggleDropdown('shapes-menu')" id="btn-shape" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition flex items-center gap-1" title="Insert Shape">
                            <i class="fa-solid fa-shapes"></i> <i class="fa-solid fa-caret-down text-xs"></i>
                        </button>
                        <div id="shapes-menu" class="dropdown-menu">
                            <div onclick="setTool('line')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-minus"></i> Line
                            </div>
                            <div onclick="setTool('box')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-regular fa-square"></i> Rectangle
                            </div>
                        </div>
                    </div>

                    <!-- Magic Wand -->
                    <button onclick="setTool('magic')" id="btn-magic" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Edit Existing Text (Magic Wand)">
                        <i class="fa-solid fa-wand-magic-sparkles"></i>
                    </button>
                </div>

                <div class="h-6 w-px bg-gray-300 mx-2"></div>

                <!-- Properties -->
                <div class="flex items-center gap-2" id="properties-panel">
                    <!-- Font Size -->
                    <select id="font-size" onchange="updateSelectedProp('size')" class="h-8 text-sm border border-gray-300 rounded px-1 bg-gray-50 hover:bg-white focus:outline-none">
                        <option value="10">10 pt</option>
                        <option value="12" selected>12 pt</option>
                        <option value="14">14 pt</option>
                        <option value="18">18 pt</option>
                        <option value="24">24 pt</option>
                        <option value="36">36 pt</option>
                    </select>
                    
                    <!-- Bold -->
                    <button id="btn-bold" onmousedown="event.preventDefault()" onclick="toggleBold()" class="h-8 w-8 rounded hover:bg-gray-200 text-gray-600 font-bold text-lg" title="Bold (Ctrl/Cmd + B)">
                        B
                    </button>
                    
                    <!-- Color -->
                    <div class="relative w-8 h-8 rounded border border-gray-300 cursor-pointer overflow-hidden" title="Color">
                        <input type="color" id="elem-color" oninput="updateSelectedProp('color')" class="absolute -top-4 -left-4 w-16 h-16 cursor-pointer" value="#000000">
                    </div>

                    <button onclick="deleteSelected()" class="p-2 rounded hover:bg-red-100 text-gray-500 hover:text-red-600 transition" title="Delete Selected (Del)">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
            </div>

            <!-- Right Side Actions -->
            <div class="flex items-center gap-3">
                <button onclick="document.getElementById('file-upload').click()" class="text-sm font-medium text-gray-600 hover:text-blue-600 flex items-center gap-2">
                    <i class="fa-solid fa-folder-plus"></i> Open New
                </button>
                <button onclick="saveCurrentDoc()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-1.5 rounded shadow-sm text-sm font-medium flex items-center gap-2 transition">
                    <i class="fa-solid fa-download"></i> Save PDF
                </button>
            </div>
        </header>

        <!-- Tab Bar -->
        <div class="bg-gray-200 border-b border-gray-300 flex items-end px-2 gap-1 overflow-x-auto h-full" id="tab-bar">
            <div class="px-4 py-2 text-sm text-gray-500 italic">No document open</div>
        </div>

        <!-- Main Content -->
        <main class="relative overflow-hidden">
            <input type="file" id="file-upload" accept="application/pdf" class="hidden" onchange="handleFileSelect(event)">

            <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-100 text-gray-500 z-0">
                <div class="w-24 h-24 bg-gray-200 rounded-full flex items-center justify-center mb-4">
                    <i class="fa-regular fa-file-pdf text-4xl text-gray-400"></i>
                </div>
                <h2 class="text-xl font-semibold text-gray-700">No Document Open</h2>
                <p class="mb-6">Upload a PDF to start editing</p>
                <button onclick="document.getElementById('file-upload').click()" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition shadow">
                    Select PDF File
                </button>
            </div>

            <div id="workspace-wrapper" class="hidden w-full h-full relative">
                <div class="absolute bottom-6 right-6 z-50 bg-white rounded-lg shadow-lg border border-gray-200 flex flex-col overflow-hidden">
                    <button onclick="changeZoom(0.1)" class="p-2 hover:bg-gray-100 border-b border-gray-100"><i class="fa-solid fa-plus"></i></button>
                    <span id="zoom-label" class="text-xs text-center py-1 font-mono text-gray-500">100%</span>
                    <button onclick="changeZoom(-0.1)" class="p-2 hover:bg-gray-100"><i class="fa-solid fa-minus"></i></button>
                </div>
                <!-- Deselection happens on clicking this background -->
                <div id="pdf-workspace" onclick="handleWorkspaceClick(event)"></div>
            </div>

            <div id="loader-overlay" class="hidden absolute inset-0 z-[100] bg-black/50 flex flex-col items-center justify-center text-white">
                <div class="loader mb-3"></div>
                <span id="loader-text">Processing...</span>
            </div>
        </main>
    </div>

    <script>
        // --- Core Application State ---
        let documents = []; 
        let activeDocId = null;
        let currentTool = 'cursor';
        let selectedElement = null;
        let savedRange = null; 
        
        let SNAP_THRESHOLD = 10; 
        let MIN_SIZE = 20; 

        // --- History / Undo / Redo ---
        const historyStack = [];
        const redoStack = [];

        function pushAction(action) {
            historyStack.push(action);
            redoStack.length = 0; // Clear redo stack on new action
            console.log("Action pushed:", action.type, historyStack.length);
        }

        function performUndo() {
            if (historyStack.length === 0) return;
            const action = historyStack.pop();
            redoStack.push(action);

            console.log("Undoing:", action.type);

            switch (action.type) {
                case 'create':
                    action.elements.forEach(el => el.remove());
                    deselectAll();
                    break;
                case 'delete':
                    action.elements.forEach(el => {
                        action.parent.appendChild(el);
                        enableDragAndSelect(el); // Re-enable listeners
                    });
                    break;
                case 'move_resize':
                    const el = action.element;
                    el.style.left = action.start.left;
                    el.style.top = action.start.top;
                    el.style.width = action.start.width;
                    el.style.height = action.start.height;
                    break;
                case 'content':
                    action.element.innerHTML = action.oldContent;
                    break;
                case 'style':
                    if (action.prop === 'bold') {
                         if (action.element.style.fontWeight === 'bold') action.element.style.fontWeight = 'normal';
                         else action.element.style.fontWeight = 'bold';
                    } else if (action.prop === 'color') {
                         if (action.element.classList.contains('shape-box')) action.element.style.borderColor = action.oldVal;
                         else if (action.element.classList.contains('shape-line')) action.element.style.backgroundColor = action.oldVal;
                         else action.element.style.color = action.oldVal;
                    } else if (action.prop === 'size') {
                        action.element.style.fontSize = action.oldVal;
                    }
                    break;
            }
        }

        function performRedo() {
            if (redoStack.length === 0) return;
            const action = redoStack.pop();
            historyStack.push(action);

            console.log("Redoing:", action.type);

            switch (action.type) {
                case 'create':
                    action.elements.forEach(el => {
                        action.parent.appendChild(el);
                        enableDragAndSelect(el);
                    });
                    break;
                case 'delete':
                    action.elements.forEach(el => el.remove());
                    deselectAll();
                    break;
                case 'move_resize':
                    const el = action.element;
                    el.style.left = action.end.left;
                    el.style.top = action.end.top;
                    el.style.width = action.end.width;
                    el.style.height = action.end.height;
                    break;
                case 'content':
                    action.element.innerHTML = action.newContent;
                    break;
                case 'style':
                     if (action.prop === 'color') {
                         if (action.element.classList.contains('shape-box')) action.element.style.borderColor = action.newVal;
                         else if (action.element.classList.contains('shape-line')) action.element.style.backgroundColor = action.newVal;
                         else action.element.style.color = action.newVal;
                    } else if (action.prop === 'size') {
                        action.element.style.fontSize = action.newVal;
                    }
                    break;
            }
        }

        // --- Init ---
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // --- Event Listeners ---
        document.addEventListener('click', (e) => {
            if(!e.target.closest('.relative')) {
                document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
            }
        });

        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                performUndo();
                return;
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                performRedo();
                return;
            }

            if (document.activeElement && document.activeElement.isContentEditable) return; 
            if(e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
        });

        // Global Deselect Logic
        function handleWorkspaceClick(e) {
            // Only deselect if we clicked explicitly on the background
            if (e.target.id === 'pdf-workspace' || e.target.classList.contains('pdf-page-container')) {
                deselectAll();
            }
        }

        // --- Tab & Doc Management ---
        function getActiveDoc() { return documents.find(d => d.id === activeDocId); }
        
        function getGuides(pageOverlay) {
            if (!pageOverlay) return { horizontal: [], vertical: [] };
            const guides = Array.from(pageOverlay.querySelectorAll('.guide-line'));
            return {
                horizontal: guides.filter(el => el.classList.contains('guide-horizontal')),
                vertical: guides.filter(el => el.classList.contains('guide-vertical')),
            };
        }

        function createDocument(file) {
            showLoader(true, "Loading PDF...");
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                const newDocId = Date.now().toString();
                const newDoc = {
                    id: newDocId,
                    name: file.name,
                    fileBytes: new Uint8Array(arrayBuffer.slice(0)),
                    renderBytes: new Uint8Array(arrayBuffer.slice(0)),
                    pdfDoc: null,
                    pages: [], 
                    scale: 1.0, 
                    containerDiv: document.createElement('div'),
                };
                newDoc.containerDiv.className = "w-full flex flex-col items-center";
                documents.push(newDoc);
                renderPDFData(newDoc).then(() => {
                    setActiveDocument(newDocId);
                    renderTabs();
                    showLoader(false);
                }).catch(err => {
                    console.error("PDF Render Error:", err);
                    showLoader(false);
                });
            };
            reader.readAsArrayBuffer(file);
        }

        async function renderPDFData(docObj) {
            try {
                const loadingTask = pdfjsLib.getDocument({ data: docObj.renderBytes });
                docObj.pdfDoc = await loadingTask.promise;
                docObj.containerDiv.innerHTML = '';
                docObj.pages = [];
                for (let pageNum = 1; pageNum <= docObj.pdfDoc.numPages; pageNum++) {
                    const page = await docObj.pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: docObj.scale });
                    
                    const textContent = await page.getTextContent();
                    
                    const pageContainer = document.createElement('div');
                    pageContainer.className = 'pdf-page-container';
                    pageContainer.style.width = `${viewport.width}px`;
                    pageContainer.style.height = `${viewport.height}px`;
                    pageContainer.dataset.pageNum = pageNum;
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    
                    // The Overlay
                    const overlay = document.createElement('div');
                    overlay.className = 'page-overlay';
                    overlay.id = `overlay-${docObj.id}-${pageNum}`;
                    
                    // Click on overlay empty space to deselect
                    overlay.addEventListener('mousedown', (e) => {
                        if (e.target === overlay && currentTool === 'cursor') {
                             deselectAll();
                        }
                    });
                    
                    setupOverlayEvents(overlay, docObj);
                    
                    overlay.addEventListener('mousemove', (e) => handleMagicHover(e, textContent, viewport, overlay));
                    overlay.addEventListener('click', (e) => handleMagicClick(e, textContent, viewport, overlay));

                    pageContainer.appendChild(canvas);
                    pageContainer.appendChild(overlay);
                    docObj.containerDiv.appendChild(pageContainer);
                    docObj.pages.push({ pageNum, viewport, width: viewport.width, height: viewport.height, element: overlay });
                }
            } catch (err) { console.error(err); throw new Error("Error rendering PDF"); }
        }

        function setActiveDocument(id) {
            deselectAll();
            activeDocId = id;
            const doc = documents.find(d => d.id === id);
            document.getElementById('empty-state').classList.add('hidden');
            document.getElementById('workspace-wrapper').classList.remove('hidden');
            const workspace = document.getElementById('pdf-workspace');
            workspace.innerHTML = ''; 
            workspace.appendChild(doc.containerDiv); 
            document.getElementById('zoom-label').innerText = Math.round(doc.scale * 100) + '%';
            doc.containerDiv.style.transform = `scale(${doc.scale})`;
            renderTabs();
        }

        function closeDocument(e, id) {
            e.stopPropagation();
            documents = documents.filter(d => d.id !== id);
            if(documents.length === 0) {
                activeDocId = null;
                document.getElementById('empty-state').classList.remove('hidden');
                document.getElementById('workspace-wrapper').classList.add('hidden');
            } else if (activeDocId === id) setActiveDocument(documents[documents.length - 1].id);
            else renderTabs();
        }

        function renderTabs() {
            const bar = document.getElementById('tab-bar');
            bar.innerHTML = '';
            if(documents.length === 0) { bar.innerHTML = '<div class="px-4 py-2 text-sm text-gray-500 italic">No document open</div>'; return; }
            documents.forEach(doc => {
                const isActive = doc.id === activeDocId;
                const tab = document.createElement('div');
                tab.className = `tab-item px-4 py-2 text-sm cursor-pointer flex items-center gap-2 border-r border-gray-300 ${isActive ? 'active' : 'bg-gray-100 text-gray-600 hover:bg-gray-50'}`;
                tab.innerHTML = `<span class="truncate max-w-[120px]">${doc.name}</span><button class="hover:text-red-500 rounded-full p-0.5" onclick="closeDocument(event, '${doc.id}')"><i class="fa-solid fa-xmark"></i></button>`;
                tab.onclick = () => setActiveDocument(doc.id);
                bar.appendChild(tab);
            });
        }

        // --- Tools Logic ---
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) createDocument(file);
            event.target.value = ''; 
        }

        function setTool(name) {
            currentTool = name;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            if(name === 'line' || name === 'box') document.getElementById('btn-shape').classList.add('active');
            else if (name === 'guide-h' || name === 'guide-v') document.getElementById('btn-guide').classList.add('active');
            else {
                const btn = document.getElementById(`btn-${name}`);
                if(btn) btn.classList.add('active');
            }
            document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
            const ws = document.getElementById('pdf-workspace');
            
            if (name === 'magic') ws.style.cursor = 'context-menu'; 
            else if (name !== 'cursor') ws.style.cursor = 'crosshair'; 
            else ws.style.cursor = 'default';
            
            document.querySelectorAll('.magic-highlight').forEach(el => el.remove());
            deselectAll();
        }

        function toggleDropdown(id) { document.getElementById(id).classList.toggle('show'); }
        
        // --- Magic Text Feature ---
        let highlightedItem = null;

        function handleMagicHover(e, textContent, viewport, overlay) {
            if (currentTool !== 'magic') return;
            
            const existing = overlay.querySelector('.magic-highlight');
            if (existing) existing.remove();
            highlightedItem = null;

            const x = e.offsetX;
            const y = e.offsetY;

            for (const item of textContent.items) {
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                const vx = tx[4];
                const vy = tx[5]; 
                
                const fontSize = Math.sqrt(tx[2]*tx[2] + tx[3]*tx[3]); 
                const realWidth = item.width * Math.sqrt(tx[0]*tx[0] + tx[1]*tx[1]); 
                
                const padding = 5;

                if (x >= vx - padding && x <= vx + realWidth + padding && 
                    y <= vy + padding && y >= vy - fontSize - padding) {
                    
                    highlightedItem = { item, vx, vy, w: realWidth, h: fontSize };
                    
                    const hl = document.createElement('div');
                    hl.className = 'magic-highlight';
                    hl.style.left = vx + 'px';
                    hl.style.top = (vy - fontSize) + 'px';
                    hl.style.width = realWidth + 'px';
                    hl.style.height = fontSize + 'px';
                    overlay.appendChild(hl);
                    break;
                }
            }
        }

        function handleMagicClick(e, textContent, viewport, overlay) {
            if (currentTool !== 'magic' || !highlightedItem) return;
            e.stopPropagation();

            const { item, vx, vy, w, h } = highlightedItem;
            
            // Whiteout
            const whiteout = document.createElement('div');
            whiteout.className = 'editor-element whiteout-box';
            whiteout.style.left = (vx - 2) + 'px';
            whiteout.style.top = (vy - h - 2) + 'px';
            whiteout.style.width = (w + 5) + 'px';
            whiteout.style.height = (h + 4) + 'px';
            overlay.appendChild(whiteout);

            // New Text
            const newText = document.createElement('div');
            newText.className = 'editor-element added-text';
            newText.contentEditable = true; // Set to True on creation like old code
            newText.style.left = vx + 'px';
            newText.style.top = (vy - h * 1.1) + 'px'; 
            newText.style.fontSize = Math.round(h) + 'px';
            newText.style.color = '#000000';
            newText.innerText = item.str;
            
            overlay.appendChild(newText);
            
            // Record Action for Undo
            pushAction({
                type: 'create',
                elements: [whiteout, newText],
                parent: overlay
            });
            
            setTool('cursor');
            enableDragAndSelect(newText);
            selectElement(newText);
            // Setup events
            setupTextEditing(newText);
            
            setTimeout(() => {
                newText.focus();
                newText.classList.add('is-editing');
                document.execCommand('selectAll',false,null);
            }, 10);
        }

        // --- Interaction Logic ---
        function setupOverlayEvents(overlay, docObj) {
            let startX, startY;
            let currentDrawing = null;

            overlay.addEventListener('mousedown', (e) => {
                if(e.target !== overlay) return;

                if(currentTool.startsWith('guide')) {
                    const el = createGuide(overlay, currentTool === 'guide-h' ? e.offsetY : e.offsetX, currentTool === 'guide-h' ? 'horizontal' : 'vertical');
                    pushAction({ type: 'create', elements: [el], parent: overlay });
                    setTool('cursor');
                    return;
                }
                
                if (currentTool === 'cursor' || currentTool === 'magic') return; 

                startX = e.offsetX;
                startY = e.offsetY;

                currentDrawing = document.createElement('div');
                currentDrawing.className = 'editor-element';
                currentDrawing.style.left = startX + 'px';
                currentDrawing.style.top = startY + 'px';
                
                if(currentTool === 'whiteout') currentDrawing.classList.add('whiteout-box');
                else if(currentTool === 'box') currentDrawing.classList.add('shape-box');
                else if(currentTool === 'line') {
                    currentDrawing.classList.add('shape-line');
                    currentDrawing.style.height = '2px'; 
                } else if (currentTool === 'text') {
                    currentDrawing.classList.add('added-text');
                    currentDrawing.contentEditable = true; // Set to True
                    currentDrawing.style.fontSize = document.getElementById('font-size').value + 'px';
                    currentDrawing.style.color = document.getElementById('elem-color').value;
                    currentDrawing.innerHTML = 'Type here';
                }

                overlay.appendChild(currentDrawing);
                selectElement(currentDrawing); 
            });

            overlay.addEventListener('mousemove', (e) => {
                if(!currentDrawing) return;
                const width = e.offsetX - startX;
                const height = e.offsetY - startY;
                const finalWidth = Math.max(MIN_SIZE, Math.abs(width));
                const finalHeight = Math.max(MIN_SIZE, Math.abs(height));

                currentDrawing.style.width = finalWidth + 'px';
                currentDrawing.style.height = finalHeight + 'px';
                currentDrawing.style.left = (width < 0 ? startX - finalWidth : startX) + 'px';
                currentDrawing.style.top = (height < 0 ? startY - finalHeight : startY) + 'px';

                if(currentTool === 'line') {
                    currentDrawing.style.height = '2px';
                    currentDrawing.style.top = startY + 'px';
                }
            });

            overlay.addEventListener('mouseup', () => {
                if(currentDrawing) {
                    const el = currentDrawing;
                    if(el.offsetWidth < MIN_SIZE || el.offsetHeight < MIN_SIZE) {
                        el.remove();
                        selectedElement = null; 
                    } else {
                        if(currentTool === 'box') el.style.borderColor = document.getElementById('elem-color').value;
                        else if(currentTool === 'line') el.style.backgroundColor = document.getElementById('elem-color').value;
                        
                        enableDragAndSelect(el);
                        selectElement(el); 
                        
                        pushAction({ type: 'create', elements: [el], parent: overlay });

                        if(currentTool === 'text' && el.isConnected) {
                             setupTextEditing(el);
                             setTimeout(() => {
                                el.focus();
                                el.classList.add('is-editing');
                                document.execCommand('selectAll',false,null);
                            }, 10);
                        }
                    }
                    currentDrawing = null;
                    setTool('cursor'); 
                }
            });
        }
        
        function setupTextEditing(el) {
            el.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                el.focus();
                el.classList.add('is-editing');
            });
            
            el.addEventListener('blur', () => { 
                // Capture content change for Undo logic could go here
                el.classList.remove('is-editing');
            });
            el.addEventListener('focus', () => { 
                el.classList.add('is-editing'); 
                checkSelectionState();
            });
            // Capture initial content for undo when entering edit mode logic omitted for brevity in this specific fix
            // but we can add 'input' listeners if needed.
        }

        function createGuide(parent, pos, type) {
            const el = document.createElement('div');
            el.className = 'editor-element guide-line ' + (type === 'horizontal' ? 'guide-horizontal' : 'guide-vertical');
            if(type === 'horizontal') { el.style.top = pos + 'px'; el.dataset.dragY = 'true'; }
            else { el.style.left = pos + 'px'; el.dataset.dragX = 'true'; }
            parent.appendChild(el);
            enableDragAndSelect(el);
            selectElement(el);
            return el;
        }

        function enableDragAndSelect(el) {
            let isDragging = false;
            let offset = [0,0];
            let startState = null;

            function isEditing() { return el.classList.contains('added-text') && el.classList.contains('is-editing'); }

            el.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) return;
                
                // If editing, don't drag. If not Cursor tool, don't drag.
                if (isEditing() || (currentTool !== 'cursor' && !el.classList.contains('guide-line'))) { 
                    return; 
                }
                
                e.stopPropagation(); 
                e.preventDefault(); // <--- CRITICAL: Prevents contentEditable from stealing focus, allowing drag
                
                selectElement(el);
                
                isDragging = true;
                el.style.cursor = 'grabbing';
                offset = [el.offsetLeft - e.clientX, el.offsetTop - e.clientY];
                
                startState = { 
                    left: el.style.left, top: el.style.top, 
                    width: el.style.width, height: el.style.height 
                };
            }); 
            
            // Double click handled in setupTextEditing

            document.addEventListener('mouseup', () => {
                if(isDragging) {
                    isDragging = false;
                    if(el.classList.contains('guide-horizontal')) el.style.cursor = 'ns-resize';
                    else if(el.classList.contains('guide-vertical')) el.style.cursor = 'ew-resize';
                    else if(!isEditing()) el.style.cursor = 'move';
                    
                    if (startState && (el.style.left !== startState.left || el.style.top !== startState.top)) {
                        pushAction({
                            type: 'move_resize',
                            element: el,
                            start: startState,
                            end: { left: el.style.left, top: el.style.top, width: el.style.width, height: el.style.height }
                        });
                    }
                    startState = null;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if(!isDragging) return;
                e.preventDefault();
                let newLeft = e.clientX + offset[0];
                let newTop = e.clientY + offset[1];
                
                if (el.dataset.dragY) el.style.top = newTop + 'px';
                else if (el.dataset.dragX) el.style.left = newLeft + 'px';
                else { el.style.left = newLeft + 'px'; el.style.top = newTop + 'px'; }
            });
        }

        function addResizingHandles(el) {
            el.querySelectorAll('.resize-handle').forEach(h => h.remove());
            ['tl', 'tr', 'bl', 'br'].forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos} w-3 h-3 bg-blue-500 border border-white rounded-full absolute z-50`;
                if(pos.includes('t')) handle.style.top = '-6px';
                if(pos.includes('b')) handle.style.bottom = '-6px';
                if(pos.includes('l')) handle.style.left = '-6px';
                if(pos.includes('r')) handle.style.right = '-6px';
                handle.style.cursor = (pos==='tl'||pos==='br') ? 'nwse-resize' : 'nesw-resize';
                handle.dataset.position = pos;
                el.appendChild(handle);
                handle.addEventListener('mousedown', startResize);
            });
        }

        let isResizing=false, resizeHandle=null, resizeEl=null, rStart={}, rStartState=null;
        function startResize(e) {
            e.stopPropagation();
            isResizing = true;
            resizeHandle = e.target;
            resizeEl = resizeHandle.closest('.editor-element');
            rStart = { x: e.clientX, y: e.clientY, w: resizeEl.offsetWidth, h: resizeEl.offsetHeight, l: resizeEl.offsetLeft, t: resizeEl.offsetTop };
            rStartState = { left: resizeEl.style.left, top: resizeEl.style.top, width: resizeEl.style.width, height: resizeEl.style.height };
            document.addEventListener('mousemove', duringResize);
            document.addEventListener('mouseup', endResize);
        }
        function duringResize(e) {
            if(!isResizing) return;
            e.preventDefault();
            const dx = e.clientX - rStart.x;
            const dy = e.clientY - rStart.y;
            const p = resizeHandle.dataset.position;
            let nw = rStart.w, nh = rStart.h, nl = rStart.l, nt = rStart.t;

            if(p.includes('l')) { nw -= dx; if(nw >= MIN_SIZE) nl += dx; else nw = MIN_SIZE; }
            else if(p.includes('r')) { nw += dx; nw = Math.max(MIN_SIZE, nw); }
            
            if(p.includes('t')) { nh -= dy; if(nh >= MIN_SIZE) nt += dy; else nh = MIN_SIZE; }
            else if(p.includes('b')) { nh += dy; nh = Math.max(MIN_SIZE, nh); }

            resizeEl.style.width = nw + 'px';
            resizeEl.style.height = nh + 'px';
            if(p.includes('l')) resizeEl.style.left = nl + 'px';
            if(p.includes('t')) resizeEl.style.top = nt + 'px';
        }
        function endResize() {
            if (isResizing && rStartState) {
                pushAction({
                    type: 'move_resize',
                    element: resizeEl,
                    start: rStartState,
                    end: { left: resizeEl.style.left, top: resizeEl.style.top, width: resizeEl.style.width, height: resizeEl.style.height }
                });
            }
            isResizing = false;
            document.removeEventListener('mousemove', duringResize);
            document.removeEventListener('mouseup', endResize);
        }

        function selectElement(el) {
            if (selectedElement && selectedElement !== el) deselectAll();
            selectedElement = el;
            el.classList.add('selected');
            // Ensure handles are created if missing
            if (!el.querySelector('.resize-handle')) addResizingHandles(el);
            
            if(el.classList.contains('added-text')) checkSelectionState();
        }

        function deselectAll() {
            if (selectedElement) {
                selectedElement.classList.remove('selected');
                selectedElement.classList.remove('is-editing');
                if(selectedElement.blur) selectedElement.blur();
            }
            selectedElement = null;
        }

        // --- Helpers ---
        function checkSelectionState() {
            if (!selectedElement || !selectedElement.classList.contains('added-text')) return;
            const isBold = document.queryCommandState('bold');
            if(isBold) document.getElementById('btn-bold').classList.add('bg-gray-200');
            else document.getElementById('btn-bold').classList.remove('bg-gray-200');
        }

        function saveSelection() {
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                if (selectedElement && selectedElement.contains(range.commonAncestorContainer)) {
                     savedRange = range;
                }
            }
        }
        function restoreSelection() {
            if (savedRange && selectedElement) {
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(savedRange);
            }
        }
        
        function toggleBold() {
            if (!selectedElement) return;
            
            if (selectedElement.classList.contains('added-text')) {
                // If in active edit mode (cursor inside), use rich text command
                if (selectedElement.classList.contains('is-editing')) {
                     selectedElement.focus();
                     restoreSelection();
                     document.execCommand('bold', false, null);
                } else {
                    // If just selected (box selection), toggle the CSS font-weight
                    // This allows user to bold the whole box without diving into it
                    const current = selectedElement.style.fontWeight;
                    selectedElement.style.fontWeight = (current === 'bold' || parseInt(current) >= 700) ? 'normal' : 'bold';
                    
                    // Push action for undo
                     pushAction({
                        type: 'style',
                        element: selectedElement,
                        prop: 'bold',
                        oldVal: current,
                        newVal: selectedElement.style.fontWeight
                    });
                }
                checkSelectionState();
            }
        }
        
        function updateSelectedProp(type) {
            if(!selectedElement) return;
            const val = type === 'size' ? document.getElementById('font-size').value : document.getElementById('elem-color').value;

            // Push Undo for style
            const oldVal = (type === 'size') ? selectedElement.style.fontSize : selectedElement.style.color; 
            
            if(selectedElement.classList.contains('added-text')) {
                if (selectedElement.classList.contains('is-editing')) {
                    selectedElement.focus();
                    restoreSelection();
                    if (type === 'color') document.execCommand('foreColor', false, val);
                    else if (type === 'size') {
                        const id = "fs-" + Date.now();
                        document.execCommand('fontSize', false, "7");
                        const fonts = selectedElement.querySelectorAll('font[size="7"]');
                        fonts.forEach(f => { f.removeAttribute("size"); f.style.fontSize = val + "px"; });
                    }
                } else {
                    if(type === 'color') selectedElement.style.color = val;
                    if(type === 'size') selectedElement.style.fontSize = val + 'px';
                }
            } else {
                if(type === 'color') {
                    if(selectedElement.classList.contains('shape-box')) selectedElement.style.borderColor = val;
                    else if(selectedElement.classList.contains('shape-line')) selectedElement.style.backgroundColor = val;
                }
            }
            
             pushAction({
                type: 'style',
                element: selectedElement,
                prop: type,
                oldVal: oldVal,
                newVal: val
            });
        }
        
        function deleteSelected() {
            if(selectedElement && !selectedElement.classList.contains('is-editing')) {
                const parent = selectedElement.parentElement;
                pushAction({ type: 'delete', elements: [selectedElement], parent: parent });
                selectedElement.remove();
                selectedElement = null;
            }
        }

        function rgbToHex(col) {
            if(!col) return '#000000';
            if(col.startsWith('#')) return col;
            const rgb = col.match(/\d+/g);
            if(!rgb) return '#000000';
            return "#" + ("0"+parseInt(rgb[0],10).toString(16)).slice(-2) + ("0"+parseInt(rgb[1],10).toString(16)).slice(-2) + ("0"+parseInt(rgb[2],10).toString(16)).slice(-2);
        }

        function changeZoom(delta) {
            if(!activeDocId) return;
            const doc = getActiveDoc();
            doc.scale = parseFloat((doc.scale + delta).toFixed(1));
            if(doc.scale < 0.5) doc.scale = 0.5;
            if(doc.scale > 3.0) doc.scale = 3.0;
            doc.containerDiv.style.transform = `scale(${doc.scale})`;
            document.getElementById('zoom-label').innerText = Math.round(doc.scale * 100) + '%';
        }

        function extractTextSegments(node, currentStyle) {
            const segments = [];
            if (node.nodeType === Node.TEXT_NODE) {
                if (node.nodeValue.length > 0) { 
                    segments.push({ text: node.nodeValue, style: { ...currentStyle } });
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const newStyle = { ...currentStyle };
                const s = window.getComputedStyle(node);
                if (s.fontWeight === 'bold' || parseInt(s.fontWeight) >= 700 || node.tagName === 'B' || node.tagName === 'STRONG') newStyle.isBold = true;
                if (s.color) newStyle.color = rgbToHex(s.color);
                if (s.fontSize) newStyle.fontSize = parseFloat(s.fontSize);
                node.childNodes.forEach(child => {
                    segments.push(...extractTextSegments(child, newStyle));
                });
            }
            return segments;
        }

        async function saveCurrentDoc() {
            if(!activeDocId) return;
            const doc = getActiveDoc();
            showLoader(true, "Generating PDF...");
            try {
                const pdfDocLib = await PDFLib.PDFDocument.load(doc.fileBytes);
                const standardFont = await pdfDocLib.embedFont(PDFLib.StandardFonts.Helvetica);
                const boldFont = await pdfDocLib.embedFont(PDFLib.StandardFonts.HelveticaBold);
                const pages = pdfDocLib.getPages();
                doc.pages.forEach((p, index) => {
                    const pdfPage = pages[index];
                    const { width, height } = pdfPage.getSize(); 
                    const scale = doc.scale; 
                    const elements = Array.from(p.element.children).filter(el => el.classList.contains('editor-element'));
                    elements.forEach(el => {
                        if(el.classList.contains('guide-line')) return;
                        const style = window.getComputedStyle(el);
                        const left = parseFloat(style.left) / scale; 
                        const top = parseFloat(style.top) / scale;
                        const elWidth = parseFloat(style.width) / scale;
                        const elHeight = parseFloat(style.height) / scale;
                        if(el.classList.contains('added-text')) {
                            const baseFontSize = parseFloat(style.fontSize) / scale;
                            const baseColor = rgbToHex(style.color);
                            const segments = extractTextSegments(el, { 
                                isBold: (style.fontWeight === 'bold' || parseInt(style.fontWeight) >= 700), 
                                color: baseColor, 
                                fontSize: baseFontSize 
                            });
                            let cursorX = left;
                            let cursorY = height - top - baseFontSize + (baseFontSize * 0.2); 
                            let currentLineHeight = baseFontSize * 1.2;
                            segments.forEach(seg => {
                                const font = seg.style.isBold ? boldFont : standardFont;
                                const fontSize = (seg.style.fontSize) ? (seg.style.fontSize / scale) : baseFontSize;
                                const rgb = hexToRgb(seg.style.color);
                                const color = PDFLib.rgb(rgb.r/255, rgb.g/255, rgb.b/255);
                                const words = seg.text.split(/(\s+)/); 
                                words.forEach(word => {
                                    const widthOfWord = font.widthOfTextAtSize(word, fontSize);
                                    if (cursorX + widthOfWord > left + elWidth && cursorX > left) {
                                        cursorX = left;
                                        cursorY -= currentLineHeight;
                                    }
                                    pdfPage.drawText(word, { x: cursorX, y: cursorY, size: fontSize, font: font, color: color });
                                    cursorX += widthOfWord;
                                });
                            });
                        } else {
                            const rgb = hexToRgb(el.style.borderColor || el.style.backgroundColor || '#000000');
                            const pdfColor = PDFLib.rgb(rgb.r/255, rgb.g/255, rgb.b/255);
                            const pdfY = height - top - elHeight;
                            if (el.classList.contains('whiteout-box')) {
                                pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, color: PDFLib.rgb(1,1,1), borderOpacity: 0 });
                            } else if (el.classList.contains('shape-line')) {
                                pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, color: pdfColor });
                            } else if (el.classList.contains('shape-box')) {
                                pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, borderColor: pdfColor, borderWidth: 2/scale, opacity: 1 });
                            }
                        }
                    });
                });
                const pdfBytes = await pdfDocLib.save();
                downloadBlob(pdfBytes, "edited_" + doc.name);
            } catch(e) { console.error(e); console.error("Save failed."); } finally { showLoader(false); }
        }

        function downloadBlob(data, fileName) {
            const blob = new Blob([data], { type: "application/pdf" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function showLoader(show, text = "Processing...") {
            const l = document.getElementById('loader-overlay');
            document.getElementById('loader-text').innerText = text;
            if(show) l.classList.remove('hidden');
            else l.classList.add('hidden');
        }

        // --- MISSING HEX TO RGB FUNCTION ADDED HERE ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
    </script>
</body>
</html>