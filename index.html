<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro PDF Editor Suite</title>
    <link rel="icon" type="image/png" href="logo.png">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@0.0.4/dist/fontkit.umd.min.js"></script>
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        body { font-family: 'Inter', sans-serif; background-color: #1e1e1e; overflow: hidden; touch-action: none; }
        
        /* Layout Grid */
        #app-container {
            display: grid;
            grid-template-rows: 60px 40px 1fr;
            height: 100vh;
        }

        /* Workspace */
        #pdf-workspace {
            overflow: auto;
            background-color: #525659;
            position: relative;
            height: 100%;
            padding: 20px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            touch-action: pan-x pan-y; 
        }

        .pdf-page-container {
            position: relative;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            background: white;
            transform-origin: center center;
            transition: transform 0.3s ease;
            z-index: 1; 
        }

        /* Overlay & Elements */
        .page-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: all; 
            overflow: hidden;
            z-index: 10;
            touch-action: none; 
        }

        /* Custom Elements Common */
        .editor-element {
            position: absolute;
            user-select: none; 
            box-sizing: border-box;
            touch-action: none; 
            min-width: 5px; 
            min-height: 1px; 
        }
        .editor-element:hover { outline: 1px dashed #3b82f6; }
        
        /* Layering Strategy */
        .whiteout-box { background-color: white; border: none; z-index: 10; } 
        .highlight-box { background-color: #ffff00; opacity: 0.4; mix-blend-mode: multiply; z-index: 15; }
        .shape-box { border: 2px solid #000; background: transparent; z-index: 20; }
        .shape-line { background-color: #000; z-index: 20; }
        .image-box, .signature-box { z-index: 25; background-size: contain; background-repeat: no-repeat; background-position: center; }

        /* Specific Elements - Updated for tighter spacing */
        .added-text {
            color: #000;
            line-height: 1.0; /* Tighter line height for forms */
            padding: 0px 2px; /* Minimal padding */
            white-space: pre-wrap; /* Preserve spaces but allow wrap */
            word-break: break-word; 
            overflow: visible; 
            cursor: default;
            background: transparent;
            z-index: 30; 
        }
        .added-text:hover { background-color: rgba(59, 130, 246, 0.05); }
        
        /* Selected State */
        .editor-element.selected { 
            outline: 2px solid #2563eb; 
            z-index: 100 !important; 
            cursor: move; 
        }

        /* Dragging State */
        .editor-element.dragging {
            opacity: 0.8;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 9999 !important;
            cursor: move !important;
        }

        /* Editing State */
        .added-text.selected.is-editing {
            outline: 1px dashed #ef4444; /* Less intrusive outline */
            cursor: text !important; 
            user-select: text !important; 
            -webkit-user-select: text !important;
        }

        /* Magic Selection Box */
        .selection-box {
            position: absolute;
            border: 1px dashed #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
            z-index: 100;
            pointer-events: none;
        }
        
        /* Resizing Handles */
        .resize-handle {
            position: absolute;
            z-index: 200 !important; 
            touch-action: none;
            display: none; 
            width: 12px; 
            height: 12px;
            background-color: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: all;
        }
        .editor-element.selected .resize-handle { display: block; }

        /* Guides */
        .guide-line {
            background-color: #06b6d4; 
            pointer-events: all;
            z-index: 200; 
            border: none !important; 
            outline: none !important;
            opacity: 0.5; 
        }
        .guide-line.selected { background-color: #ef4444; opacity: 1; }
        .guide-horizontal { height: 1px; min-height: 1px; width: 100%; left: 0; cursor: ns-resize; }
        .guide-vertical { width: 1px; min-width: 1px; height: 100%; top: 0; cursor: ew-resize; }

        /* Tools Active State */
        .tool-btn { position: relative; min-width: 36px; min-height: 36px; display: flex; align-items: center; justify-content: center; }
        .tool-btn.active {
            background-color: #e0f2fe;
            color: #0284c7;
            border-color: #0284c7;
        }

        /* Scrollbars */
        .toolbar-scroll { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
        .toolbar-scroll::-webkit-scrollbar { display: none; }

        /* Tabs & Loader */
        .tab-item { user-select: none; max-width: 150px; flex-shrink: 0; }
        .tab-item.active { background-color: #525659; color: white; border-bottom: 2px solid #60a5fa; }
        
        /* Dropdowns */
        .dropdown-menu { 
            display: none; 
            position: fixed; 
            background: white; 
            border: 1px solid #e5e5e5; 
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); 
            border-radius: 6px; 
            z-index: 9999; 
            min-width: 150px; 
            padding: 4px; 
        }
        .dropdown-menu.show { display: block; }
        
        /* Context Menu */
        #context-menu {
            display: none;
            position: fixed;
            background: white;
            border: 1px solid #e5e5e5;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-radius: 6px;
            z-index: 10000;
            min-width: 160px;
            padding: 4px 0;
        }
        #context-menu.show { display: block; }
        .ctx-item {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
        }
        .ctx-item:hover { background-color: #f3f4f6; }
        .ctx-item.disabled { color: #9ca3af; pointer-events: none; }
        .ctx-item i { width: 16px; }
        .ctx-divider { height: 1px; background-color: #e5e5e5; margin: 4px 0; }
        
        .loader { border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #3498db; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Page Manager Sidebar */
        #page-sidebar {
            position: fixed; top: 60px; left: 0; bottom: 0; width: 250px;
            background: #f3f4f6; border-right: 1px solid #d1d5db;
            transform: translateX(-100%); transition: transform 0.3s ease;
            z-index: 40; display: flex; flex-direction: column;
        }
        #page-sidebar.open { transform: translateX(0); }
        .page-thumb-item {
            background: white; margin: 10px; padding: 10px; border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: space-between;
        }
        
        /* Modals */
        #sig-modal, #delete-confirm-modal { background: rgba(0,0,0,0.5); }
        
        /* Drop Zone Highlight */
        .drop-active { outline: 4px dashed #3b82f6; outline-offset: -4px; }
    </style>
</head>
<body id="main-body" oncontextmenu="handleContextMenu(event)">

    <div id="app-container">
        
        <!-- Header / Toolbar -->
        <header class="bg-white border-b border-gray-200 flex items-center px-2 z-50 shadow-sm toolbar-scroll">
            <div class="flex items-center gap-2 md:gap-4 w-full min-w-max">
                <!-- Page Manager Toggle -->
                <button onclick="togglePageSidebar()" class="tool-btn px-3 py-2 rounded hover:bg-gray-100 text-gray-700 mr-2 border border-gray-200 flex items-center gap-2" title="Page Manager">
                    <i class="fa-solid fa-layer-group"></i> <span class="text-xs font-semibold">Pages</span>
                </button>

                <div class="flex items-center gap-2 text-gray-700 font-bold text-lg select-none mr-2">
                    <div class="bg-red-600 text-white p-1 rounded-md text-sm"><i class="fa-solid fa-file-pdf"></i></div>
                    <span class="hidden md:inline">PDF Studio</span>
                </div>
                
                <div class="h-6 w-px bg-gray-300 mx-1"></div>
                
                <!-- History Tools -->
                <div class="flex items-center gap-1">
                    <button onclick="performUndo()" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Undo (Ctrl+Z)">
                        <i class="fa-solid fa-rotate-left"></i>
                    </button>
                    <button onclick="performRedo()" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Redo (Ctrl+Y)">
                        <i class="fa-solid fa-rotate-right"></i>
                    </button>
                </div>

                <div class="h-6 w-px bg-gray-300 mx-1"></div>

                <!-- Main Tools -->
                <div id="main-tools" class="flex items-center gap-1">
                    <button onclick="setTool('cursor')" id="btn-cursor" class="tool-btn active p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Select">
                        <i class="fa-solid fa-arrow-pointer"></i>
                    </button>
                    
                    <button onclick="setTool('text')" id="btn-text" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Text">
                        <i class="fa-solid fa-font"></i>
                    </button>

                    <button onclick="setTool('highlight')" id="btn-highlight" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Highlighter">
                        <i class="fa-solid fa-highlighter"></i>
                    </button>

                    <button onclick="openSignatureModal()" id="btn-signature" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Signature">
                        <i class="fa-solid fa-signature"></i>
                    </button>
                    
                    <button onclick="document.getElementById('image-insert-input').click()" id="btn-image" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Insert Image">
                        <i class="fa-regular fa-image"></i>
                    </button>
                    
                    <!-- Guides Dropdown -->
                    <div>
                        <button onclick="toggleDropdown(event, 'guides-menu')" id="btn-guide" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition flex items-center gap-1" title="Guides">
                            <i class="fa-solid fa-ruler-combined"></i> <i class="fa-solid fa-caret-down text-xs"></i>
                        </button>
                        <div id="guides-menu" class="dropdown-menu">
                            <div onclick="setTool('guide-h')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-ruler-horizontal"></i> H. Guide
                            </div>
                            <div onclick="setTool('guide-v')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-ruler-vertical"></i> V. Guide
                            </div>
                        </div>
                    </div>

                    <button onclick="setTool('whiteout')" id="btn-whiteout" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Whiteout">
                        <i class="fa-solid fa-eraser"></i>
                    </button>

                    <!-- Shapes Dropdown -->
                    <div>
                        <button onclick="toggleDropdown(event, 'shapes-menu')" id="btn-shape" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition flex items-center gap-1" title="Shapes">
                            <i class="fa-solid fa-shapes"></i> <i class="fa-solid fa-caret-down text-xs"></i>
                        </button>
                        <div id="shapes-menu" class="dropdown-menu">
                            <div onclick="setTool('line')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-minus"></i> Line
                            </div>
                            <div onclick="setTool('box')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-regular fa-square"></i> Rectangle
                            </div>
                        </div>
                    </div>

                    <!-- Magic Wand -->
                    <button onclick="setTool('magic')" id="btn-magic" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Magic Edit">
                        <i class="fa-solid fa-wand-magic-sparkles"></i>
                    </button>
                </div>

                <div class="h-6 w-px bg-gray-300 mx-1"></div>

                <!-- Properties -->
                <div class="flex items-center gap-2" id="properties-panel">
                     <select id="font-family" onchange="updateSelectedProp('font')" class="h-9 text-sm border border-gray-300 rounded px-1 bg-gray-50 hover:bg-white focus:outline-none w-24">
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times">Times</option>
                        <option value="Courier">Courier</option>
                    </select>

                    <!-- Changed to Input for Custom Size -->
                    <div class="relative w-16" title="Font Size">
                        <input type="number" id="font-size" value="12" min="1" max="200" oninput="updateSelectedProp('size')" class="h-9 w-full text-sm border border-gray-300 rounded px-1 bg-gray-50 hover:bg-white focus:outline-none text-center">
                    </div>
                    
                    <button id="btn-bold" onmousedown="event.preventDefault()" onclick="toggleBold()" class="h-9 w-9 rounded hover:bg-gray-200 text-gray-600 font-bold text-lg border border-transparent" title="Bold">B</button>
                    
                    <div class="relative w-9 h-9 rounded border border-gray-300 cursor-pointer overflow-hidden flex-shrink-0" title="Color">
                        <input type="color" id="elem-color" oninput="updateSelectedProp('color')" class="absolute -top-4 -left-4 w-16 h-16 cursor-pointer" value="#000000">
                    </div>

                    <button onclick="deleteSelected()" class="p-2 rounded hover:bg-red-100 text-gray-500 hover:text-red-600 transition" title="Delete">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
            
                <div class="flex-grow"></div>
                
                 <!-- Actions -->
                <div class="flex items-center gap-2 ml-2">
                     <button onclick="document.getElementById('file-upload').click()" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600">
                         <i class="fa-solid fa-folder-plus"></i>
                     </button>
                    <button onclick="saveCurrentDoc()" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded shadow-sm text-sm font-medium flex items-center gap-2 transition whitespace-nowrap">
                        <i class="fa-solid fa-download"></i> <span class="hidden sm:inline">Save</span>
                    </button>
                </div>
            </div>
        </header>

        <!-- Page Sidebar -->
        <div id="page-sidebar">
            <div class="p-4 border-b border-gray-300 font-bold text-gray-700 flex justify-between items-center">
                <span>Pages</span>
                <button onclick="togglePageSidebar()" class="text-gray-500"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div id="page-list" class="flex-1 overflow-y-auto p-2">
                <!-- Page items injected here -->
            </div>
        </div>
        
        <!-- Context Menu -->
        <div id="context-menu">
            <div class="ctx-item" onclick="handleCtxCopy()">
                <i class="fa-regular fa-copy"></i> Copy <span class="text-xs text-gray-400 ml-auto">Ctrl+C</span>
            </div>
            <div class="ctx-item" onclick="handleCtxPaste()">
                <i class="fa-regular fa-paste"></i> Paste <span class="text-xs text-gray-400 ml-auto">Ctrl+V</span>
            </div>
            <div class="ctx-divider"></div>
            <div class="ctx-item text-red-600" onclick="handleCtxDelete()">
                <i class="fa-regular fa-trash-can"></i> Delete <span class="text-xs text-gray-400 ml-auto">Del</span>
            </div>
        </div>
        
        <!-- Delete Confirmation Modal -->
        <div id="delete-confirm-modal" class="hidden fixed inset-0 z-[110] flex items-center justify-center">
            <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm mx-4 text-center">
                <div class="mb-4 text-red-500 text-4xl">
                    <i class="fa-regular fa-trash-can"></i>
                </div>
                <h3 class="font-bold text-xl mb-2 text-gray-800">Delete Page?</h3>
                <p class="text-gray-600 mb-6 text-sm">Are you sure you want to remove this page? This action cannot be easily undone.</p>
                <div class="flex justify-center gap-3">
                    <button onclick="closeDeleteModal()" class="px-4 py-2 rounded border border-gray-300 text-gray-700 hover:bg-gray-50 transition">Cancel</button>
                    <button onclick="executeDeletePage()" class="px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700 transition shadow">Delete</button>
                </div>
            </div>
        </div>

        <!-- Signature Modal -->
        <div id="sig-modal" class="hidden fixed inset-0 z-[100] flex items-center justify-center">
            <div class="bg-white rounded-lg shadow-xl p-4 w-full max-w-md mx-2">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-bold text-lg">Draw Signature</h3>
                    <button onclick="closeSignatureModal()" class="text-gray-500"><i class="fa-solid fa-xmark"></i></button>
                </div>
                <div class="border border-gray-300 rounded bg-gray-50 mb-4 touch-none" style="height: 200px;">
                    <canvas id="sig-canvas" class="w-full h-full cursor-crosshair"></canvas>
                </div>
                <div class="flex justify-between">
                    <button onclick="clearSignature()" class="text-red-500 text-sm hover:underline">Clear</button>
                    <div class="flex gap-2">
                        <button onclick="closeSignatureModal()" class="px-3 py-1 text-gray-600">Cancel</button>
                        <button onclick="saveSignature()" class="bg-blue-600 text-white px-4 py-1 rounded">Add</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab Bar -->
        <div class="bg-gray-200 border-b border-gray-300 flex items-end px-2 gap-1 overflow-x-auto h-full toolbar-scroll" id="tab-bar"></div>

        <!-- Main Content -->
        <main class="relative overflow-hidden" id="main-content">
            <input type="file" id="file-upload" accept="application/pdf" class="hidden" onchange="handleFileSelect(event)">
            <input type="file" id="image-insert-input" accept="image/png, image/jpeg" class="hidden" onchange="handleImageInsert(event)">

            <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-100 text-gray-500 z-0 p-4 text-center">
                <div class="w-20 h-20 bg-gray-200 rounded-full flex items-center justify-center mb-4">
                    <i class="fa-regular fa-file-pdf text-3xl text-gray-400"></i>
                </div>
                <h2 class="text-xl font-semibold text-gray-700">No Document</h2>
                <p class="mb-6 text-sm">Upload a PDF to start or Drag & Drop here</p>
                <button onclick="document.getElementById('file-upload').click()" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition shadow">
                    Select PDF
                </button>
            </div>

            <div id="workspace-wrapper" class="hidden w-full h-full relative">
                <div class="absolute bottom-6 right-6 z-50 bg-white rounded-lg shadow-lg border border-gray-200 flex flex-col overflow-hidden">
                    <button onclick="changeZoom(0.1)" class="p-3 hover:bg-gray-100 border-b border-gray-100"><i class="fa-solid fa-plus"></i></button>
                    <span id="zoom-label" class="text-xs text-center py-1 font-mono text-gray-500">100%</span>
                    <button onclick="changeZoom(-0.1)" class="p-3 hover:bg-gray-100"><i class="fa-solid fa-minus"></i></button>
                </div>
                <div id="pdf-workspace" onclick="handleWorkspaceClick(event)"></div>
            </div>

            <div id="loader-overlay" class="hidden absolute inset-0 z-[100] bg-black/50 flex flex-col items-center justify-center text-white">
                <div class="loader mb-3"></div>
                <span id="loader-text">Processing...</span>
            </div>
        </main>
    </div>

    <script>
        // --- Constants ---
        const FONT_MAP = {
            'Helvetica': { css: 'Helvetica, Arial, sans-serif', pdf: 'Helvetica', pdfBold: 'HelveticaBold' },
            'Times': { css: "'Times New Roman', Times, serif", pdf: 'TimesRoman', pdfBold: 'TimesRomanBold' },
            'Courier': { css: "'Courier New', Courier, monospace", pdf: 'Courier', pdfBold: 'CourierBold' }
        };

        // --- IndexedDB ---
        const DB_NAME = 'PDFEditorDB';
        const DB_VERSION = 1;
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: 'id' });
                    if (!db.objectStoreNames.contains('state')) db.createObjectStore('state', { keyPath: 'id' });
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e);
            });
        }
        async function saveFileToDB(docId, name, arrayBuffer) {
            const db = await initDB();
            const tx = db.transaction(['files'], 'readwrite');
            tx.objectStore('files').put({ id: docId, name: name, data: arrayBuffer });
            return new Promise(resolve => { tx.oncomplete = resolve; });
        }
        async function saveStateToDB(docId, pagesData, scale) {
            const db = await initDB();
            const tx = db.transaction(['state'], 'readwrite');
            tx.objectStore('state').put({ id: docId, pages: pagesData, scale: scale, lastModified: Date.now() });
            return new Promise(resolve => { tx.oncomplete = resolve; });
        }
        async function loadAllFromDB() {
            const db = await initDB();
            const tx = db.transaction(['files', 'state'], 'readonly');
            const filesReq = tx.objectStore('files').getAll();
            const stateReq = tx.objectStore('state').getAll();
            return new Promise(resolve => {
                tx.oncomplete = () => {
                    const files = filesReq.result;
                    const states = stateReq.result;
                    resolve(files.map(f => ({ ...f, state: states.find(st => st.id === f.id) || null })));
                };
            });
        }
        async function deleteDocFromDB(docId) {
            const db = await initDB();
            const tx = db.transaction(['files', 'state'], 'readwrite');
            tx.objectStore('files').delete(docId);
            tx.objectStore('state').delete(docId);
        }

        // --- Core State ---
        let documents = []; 
        let activeDocId = null;
        let currentTool = 'cursor';
        let selectedElement = null;
        let clipboard = null; // Clipboard for Copy/Paste
        const SNAP_THRESHOLD = 10; 
        const MIN_SIZE = 20; 
        
        // Deletion State
        let pageToDeleteIdx = null;

        // --- History ---
        const historyStack = [];
        const redoStack = [];

        function pushAction(action) {
            historyStack.push(action);
            redoStack.length = 0; 
            if(activeDocId) {
                const doc = getActiveDoc();
                saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
            }
        }
        
        // --- Serialization ---
        function serializeDocState(doc) {
            const pagesState = {};
            doc.pages.forEach((p, idx) => {
                const elements = Array.from(p.element.children).filter(el => el.classList.contains('editor-element'));
                pagesState[idx] = elements.map(el => { // Use Index not pageNum
                    const style = el.style;
                    return {
                        classList: Array.from(el.classList).join(' '),
                        style: {
                            left: style.left, top: style.top, width: style.width, height: style.height,
                            fontSize: style.fontSize, color: style.color, 
                            borderColor: style.borderColor, backgroundColor: style.backgroundColor,
                            fontWeight: style.fontWeight, fontFamily: style.fontFamily,
                            backgroundImage: style.backgroundImage, transform: style.transform
                        },
                        innerHTML: el.innerHTML,
                        dataset: { ...el.dataset }
                    };
                });
            });
            return { pages: pagesState, rotation: doc.pageRotations };
        }

        function performUndo() {
            if (historyStack.length === 0) return;
            const action = historyStack.pop();
            redoStack.push(action);
            applyActionUndo(action);
            if(activeDocId) {
                const doc = getActiveDoc();
                saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
            }
        }
        function performRedo() {
            if (redoStack.length === 0) return;
            const action = redoStack.pop();
            historyStack.push(action);
            applyActionRedo(action);
            if(activeDocId) {
                const doc = getActiveDoc();
                saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
            }
        }

        function applyActionUndo(action) {
            if(action.type === 'create') { action.elements.forEach(el => el.remove()); deselectAll(); }
            else if(action.type === 'delete') { 
                action.elements.forEach(el => { action.parent.appendChild(el); enableDragAndSelect(el); if(el.classList.contains('added-text')) setupTextEditing(el); }); 
            }
            else if(action.type === 'move_resize') {
                const el = action.element;
                el.style.left = action.start.left; el.style.top = action.start.top;
                el.style.width = action.start.width; el.style.height = action.start.height;
            }
            else if(action.type === 'style') {
                if(action.prop === 'bold') action.element.style.fontWeight = action.oldVal;
                else if (action.prop === 'color') {
                     if (action.element.classList.contains('shape-box')) action.element.style.borderColor = action.oldVal;
                     else if (action.element.classList.contains('shape-line')) action.element.style.backgroundColor = action.oldVal;
                     else action.element.style.color = action.oldVal;
                } else if (action.prop === 'size') {
                    action.element.style.fontSize = action.oldVal;
                } else if (action.prop === 'font') {
                    action.element.style.fontFamily = action.oldVal.css;
                    action.element.dataset.fontKey = action.oldVal.key;
                }
            }
        }
        function applyActionRedo(action) {
            if(action.type === 'create') { 
                action.elements.forEach(el => { action.parent.appendChild(el); enableDragAndSelect(el); if(el.classList.contains('added-text')) setupTextEditing(el); }); 
            }
            else if(action.type === 'delete') { action.elements.forEach(el => el.remove()); deselectAll(); }
            else if(action.type === 'move_resize') {
                const el = action.element;
                el.style.left = action.end.left; el.style.top = action.end.top;
                el.style.width = action.end.width; el.style.height = action.end.height;
            }
            else if(action.type === 'style') {
                 if (action.prop === 'bold') action.element.style.fontWeight = action.newVal;
                 else if (action.prop === 'color') {
                     if (action.element.classList.contains('shape-box')) action.element.style.borderColor = action.newVal;
                     else if (action.element.classList.contains('shape-line')) action.element.style.backgroundColor = action.newVal;
                     else action.element.style.color = action.newVal;
                } else if (action.prop === 'size') {
                    action.element.style.fontSize = action.newVal;
                } else if (action.prop === 'font') {
                    action.element.style.fontFamily = action.newVal.css;
                    action.element.dataset.fontKey = action.newVal.key;
                }
            }
        }

        // --- Init ---
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        window.onload = async function() {
            showLoader(true, "Restoring session...");
            // Drag and Drop Global Events
            const body = document.body;
            body.addEventListener('dragover', (e) => { e.preventDefault(); body.classList.add('drop-active'); });
            body.addEventListener('dragleave', (e) => { e.preventDefault(); body.classList.remove('drop-active'); });
            body.addEventListener('drop', (e) => {
                e.preventDefault();
                body.classList.remove('drop-active');
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.type === 'application/pdf') {
                        // Open PDF logic
                        const reader = new FileReader();
                        reader.onload = async function(evt) {
                            const data = new Uint8Array(evt.target.result);
                            const id = Date.now().toString();
                            await saveFileToDB(id, file.name, data);
                            loadDocumentFromData(id, file.name, data, null);
                        };
                        reader.readAsArrayBuffer(file);
                    } else if (file.type.startsWith('image/') && activeDocId) {
                        // Insert Image logic
                        insertImageFromFile(file);
                    }
                }
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if(!e.target.closest('.tool-btn') && !e.target.closest('.dropdown-menu')) {
                    document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
                }
                // Hide context menu
                if(!e.target.closest('#context-menu')) {
                     document.getElementById('context-menu').classList.remove('show');
                }
            });

            try {
                const savedDocs = await loadAllFromDB();
                if(savedDocs && savedDocs.length > 0) {
                    for(const sDoc of savedDocs) await loadDocumentFromData(sDoc.id, sDoc.name, sDoc.data, sDoc.state);
                    if(documents.length > 0) setActiveDocument(documents[0].id);
                    else renderTabs();
                } else renderTabs();
            } catch(e) { console.error("Failed to load session", e); }
            showLoader(false);
        };

        // --- Event Listeners ---
        function getEventPos(e) {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY, target: e.touches[0].target };
            return { x: e.clientX, y: e.clientY, target: e.target };
        }
        
        // KEYDOWN HANDLER for Copy/Paste
        document.addEventListener('keydown', (e) => {
            // Undo / Redo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); performUndo(); return; }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); performRedo(); return; }
            
            // Copy (Ctrl+C)
            if((e.ctrlKey || e.metaKey) && e.key === 'c') {
                if(selectedElement && !selectedElement.classList.contains('is-editing')) {
                    e.preventDefault();
                    copySelected();
                }
                return;
            }
            
            // Paste (Ctrl+V)
            if((e.ctrlKey || e.metaKey) && e.key === 'v') {
                if(!document.activeElement.isContentEditable) { // Don't paste if typing in text box
                    e.preventDefault();
                    pasteClipboard();
                }
                return;
            }

            if (document.activeElement && document.activeElement.isContentEditable) return; 
            if(e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
        });

        function handleWorkspaceClick(e) {
            if (e.target.id === 'pdf-workspace' || e.target.classList.contains('pdf-page-container')) deselectAll();
        }

        // --- Copy / Paste Logic ---
        function copySelected() {
            if(!selectedElement) return;
            clipboard = {
                type: 'element',
                classList: Array.from(selectedElement.classList),
                style: {
                    width: selectedElement.style.width,
                    height: selectedElement.style.height,
                    fontSize: selectedElement.style.fontSize,
                    color: selectedElement.style.color,
                    backgroundColor: selectedElement.style.backgroundColor,
                    borderColor: selectedElement.style.borderColor,
                    fontFamily: selectedElement.style.fontFamily,
                    backgroundImage: selectedElement.style.backgroundImage,
                    fontWeight: selectedElement.style.fontWeight
                },
                innerHTML: selectedElement.innerHTML,
                dataset: { ...selectedElement.dataset }
            };
            // Visual feedback?
            console.log("Copied to clipboard");
        }

        function pasteClipboard() {
            if(!clipboard || !activeDocId) return;
            const doc = getActiveDoc();
            const pageObj = getMostVisiblePage(doc);
            
            const el = document.createElement('div');
            el.className = clipboard.classList.join(' ');
            el.classList.remove('selected', 'is-editing', 'dragging');
            
            // Apply Styles
            Object.assign(el.style, clipboard.style);
            
            // Position Center offset
            const centerX = pageObj.width / 2; 
            const centerY = pageObj.height / 2;
            // Slight random offset so multiple pastes don't stack perfectly
            const offset = Math.floor(Math.random() * 20) - 10;
            
            el.style.left = (centerX - parseInt(el.style.width||100)/2 + offset) + 'px';
            el.style.top = (centerY - parseInt(el.style.height||30)/2 + offset) + 'px';
            
            el.innerHTML = clipboard.innerHTML;
            if(clipboard.dataset) Object.assign(el.dataset, clipboard.dataset);

            if(el.classList.contains('added-text')) {
                el.contentEditable = true;
                setupTextEditing(el);
            }
            
            pageObj.element.appendChild(el);
            enableDragAndSelect(el);
            selectElement(el);
            pushAction({ type: 'create', elements: [el], parent: pageObj.element });
        }
        
        // --- Context Menu ---
        function handleContextMenu(e) {
            // Check if clicking on workspace or element
            if(e.target.closest('#pdf-workspace') || e.target.closest('.editor-element')) {
                e.preventDefault();
                const menu = document.getElementById('context-menu');
                menu.style.top = e.clientY + 'px';
                menu.style.left = e.clientX + 'px';
                menu.classList.add('show');
                
                // If clicked on element, select it first
                if(e.target.classList.contains('editor-element')) {
                    selectElement(e.target);
                } else if(e.target.parentElement.classList.contains('editor-element')) {
                    selectElement(e.target.parentElement);
                }
            }
        }
        
        function handleCtxCopy() {
            copySelected();
            document.getElementById('context-menu').classList.remove('show');
        }
        function handleCtxPaste() {
            pasteClipboard();
            document.getElementById('context-menu').classList.remove('show');
        }
        function handleCtxDelete() {
            deleteSelected();
            document.getElementById('context-menu').classList.remove('show');
        }


        // --- Document Loading ---
        function getActiveDoc() { return documents.find(d => d.id === activeDocId); }
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const data = new Uint8Array(e.target.result);
                    const id = Date.now().toString();
                    await saveFileToDB(id, file.name, data);
                    loadDocumentFromData(id, file.name, data, null);
                };
                reader.readAsArrayBuffer(file);
            }
            event.target.value = ''; 
        }

        async function loadDocumentFromData(id, name, data, savedState) {
             const newDoc = {
                id: id, name: name, fileBytes: data, renderBytes: new Uint8Array(data),
                pdfDoc: null, pages: [], scale: savedState ? savedState.scale : 1.0, 
                containerDiv: document.createElement('div'), savedState: savedState,
                pageRotations: savedState && savedState.rotation ? savedState.rotation : {}
            };
            newDoc.containerDiv.className = "w-full flex flex-col items-center pb-20";
            documents.push(newDoc);
            try {
                await renderPDFData(newDoc);
                setActiveDocument(id);
                renderTabs();
            } catch(e) { console.error(e); }
        }

        async function renderPDFData(docObj) {
            try {
                const loadingTask = pdfjsLib.getDocument({ data: docObj.renderBytes });
                docObj.pdfDoc = await loadingTask.promise;
                docObj.containerDiv.innerHTML = '';
                docObj.pages = [];
                
                for (let pageNum = 1; pageNum <= docObj.pdfDoc.numPages; pageNum++) {
                    const page = await docObj.pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: docObj.scale });
                    
                    const pageContainer = document.createElement('div');
                    pageContainer.className = 'pdf-page-container';
                    pageContainer.style.width = `${viewport.width}px`;
                    pageContainer.style.height = `${viewport.height}px`;
                    
                    // Rotation Logic
                    const rot = docObj.pageRotations[pageNum-1] || 0; // index based
                    if(rot > 0) {
                         pageContainer.style.transform = `rotate(${rot}deg)`;
                         // Fix margins for 90/270deg rotation to avoid overlap
                         if (rot % 180 !== 0) {
                             const diff = (viewport.width - viewport.height) / 2;
                             pageContainer.style.margin = `${diff}px 0`;
                         }
                    }

                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    
                    const overlay = document.createElement('div');
                    overlay.className = 'page-overlay';
                    overlay.id = `overlay-${docObj.id}-${pageNum}`;
                    
                    // Store text content for Magic Wand
                    const textContent = await page.getTextContent();
                    
                    docObj.pages.push({ pageNum, viewport, width: viewport.width, height: viewport.height, element: overlay, textContent, originalIndex: pageNum-1 });
                    
                    const deselectHandler = (e) => { if (e.target === overlay && currentTool === 'cursor') deselectAll(); };
                    overlay.addEventListener('mousedown', deselectHandler);
                    overlay.addEventListener('touchstart', deselectHandler);
                    
                    setupOverlayEvents(overlay, docObj);
                    
                    // Restore Elements
                    if(docObj.savedState && docObj.savedState.pages && docObj.savedState.pages[pageNum-1]) {
                        docObj.savedState.pages[pageNum-1].forEach(elData => {
                            const el = document.createElement('div');
                            el.className = elData.classList;
                            Object.assign(el.style, elData.style);
                            if(elData.classList.contains('image-box') || elData.classList.contains('signature-box')) {
                                el.style.backgroundImage = elData.style.backgroundImage;
                            }
                            el.innerHTML = elData.innerHTML;
                            if(elData.dataset) Object.assign(el.dataset, elData.dataset);
                            
                            if(el.classList.contains('added-text')) {
                                el.contentEditable = true;
                                setupTextEditing(el);
                            }
                            overlay.appendChild(el);
                            enableDragAndSelect(el);
                        });
                    }
                    pageContainer.appendChild(canvas);
                    pageContainer.appendChild(overlay);
                    docObj.containerDiv.appendChild(pageContainer);
                }
            } catch (err) { console.error(err); throw new Error("Error rendering PDF"); }
        }

        function setActiveDocument(id) {
            deselectAll();
            activeDocId = id;
            const doc = documents.find(d => d.id === id);
            document.getElementById('empty-state').classList.add('hidden');
            document.getElementById('workspace-wrapper').classList.remove('hidden');
            const workspace = document.getElementById('pdf-workspace');
            workspace.innerHTML = ''; 
            workspace.appendChild(doc.containerDiv); 
            document.getElementById('zoom-label').innerText = Math.round(doc.scale * 100) + '%';
            doc.containerDiv.style.transform = `scale(${doc.scale})`;
            renderTabs();
            renderPageList();
        }

        // --- Tools ---
        function setTool(name) {
            currentTool = name;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            if(name === 'line' || name === 'box') document.getElementById('btn-shape').classList.add('active');
            else if(name.startsWith('guide')) document.getElementById('btn-guide').classList.add('active');
            else {
                const btn = document.getElementById(`btn-${name}`);
                if(btn) btn.classList.add('active');
            }
            document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
            deselectAll();
        }

        // Updated toggleDropdown for fixed positioning to avoid overflow issues
        function toggleDropdown(event, id) {
            // Close all first
            const wasOpen = document.getElementById(id).classList.contains('show');
            document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
            
            if (!wasOpen && event) {
                event.stopPropagation();
                const btn = event.currentTarget;
                const menu = document.getElementById(id);
                const rect = btn.getBoundingClientRect();
                
                menu.style.top = (rect.bottom + 2) + 'px';
                menu.style.left = rect.left + 'px';
                menu.classList.add('show');
            }
        }

        // --- Signature ---
        let sigCanvas, sigCtx, isSigning = false;
        function openSignatureModal() {
            document.getElementById('sig-modal').classList.remove('hidden');
            sigCanvas = document.getElementById('sig-canvas');
            sigCtx = sigCanvas.getContext('2d');
            
            // Resize canvas
            const rect = sigCanvas.parentElement.getBoundingClientRect();
            sigCanvas.width = rect.width;
            sigCanvas.height = rect.height;
            
            sigCtx.lineWidth = 2;
            sigCtx.lineCap = 'round';
            sigCtx.strokeStyle = '#000';
            
            // Events
            sigCanvas.onmousedown = (e) => { isSigning = true; sigCtx.beginPath(); sigCtx.moveTo(e.offsetX, e.offsetY); };
            sigCanvas.onmousemove = (e) => { if(isSigning) { sigCtx.lineTo(e.offsetX, e.offsetY); sigCtx.stroke(); } };
            sigCanvas.onmouseup = () => isSigning = false;
            
            sigCanvas.ontouchstart = (e) => { 
                e.preventDefault(); 
                isSigning = true; 
                const b = sigCanvas.getBoundingClientRect();
                sigCtx.beginPath(); 
                sigCtx.moveTo(e.touches[0].clientX - b.left, e.touches[0].clientY - b.top); 
            };
            sigCanvas.ontouchmove = (e) => { 
                e.preventDefault(); 
                if(isSigning) {
                    const b = sigCanvas.getBoundingClientRect();
                    sigCtx.lineTo(e.touches[0].clientX - b.left, e.touches[0].clientY - b.top);
                    sigCtx.stroke();
                }
            };
            sigCanvas.ontouchend = () => isSigning = false;
            
            // Load previous if exists
            const saved = localStorage.getItem('userSignature');
            if(saved) {
                const img = new Image();
                img.onload = () => sigCtx.drawImage(img, 0, 0);
                img.src = saved;
            }
        }
        function closeSignatureModal() { document.getElementById('sig-modal').classList.add('hidden'); }
        function clearSignature() { sigCtx.clearRect(0,0, sigCanvas.width, sigCanvas.height); localStorage.removeItem('userSignature'); }
        function saveSignature() {
            const dataUrl = sigCanvas.toDataURL();
            localStorage.setItem('userSignature', dataUrl);
            closeSignatureModal();
            setTool('cursor');
            
            if(!activeDocId) return;
            const doc = getActiveDoc();
            const pageObj = getMostVisiblePage(doc); // Get visible page
            
            const el = document.createElement('div');
            el.className = 'editor-element signature-box';
            
            // Center on that page
            const centerX = pageObj.width / 2 - 75; // Half of width (150)
            const centerY = pageObj.height / 2 - 40; // Half of height (80) - approx center visible might be better but page center is safe default
            
            el.style.left = centerX + 'px'; el.style.top = centerY + 'px';
            el.style.width = '150px'; el.style.height = '80px';
            el.style.backgroundImage = `url(${dataUrl})`;
            pageObj.element.appendChild(el);
            enableDragAndSelect(el);
            selectElement(el);
            pushAction({ type: 'create', elements: [el], parent: pageObj.element });
        }
        
        // Helper to find visible page
        function getMostVisiblePage(doc) {
            let maxVis = 0;
            let bestPage = doc.pages[0];
            const viewH = window.innerHeight;
            
            doc.pages.forEach(p => {
                const rect = p.element.getBoundingClientRect();
                const top = Math.max(0, rect.top);
                const bottom = Math.min(viewH, rect.bottom);
                const visibleH = Math.max(0, bottom - top);
                
                if (visibleH > maxVis) {
                    maxVis = visibleH;
                    bestPage = p;
                }
            });
            return bestPage;
        }

        // --- Image Insertion ---
        function handleImageInsert(e) {
            const file = e.target.files[0];
            if(!file || !activeDocId) return;
            insertImageFromFile(file);
            e.target.value = '';
        }

        function insertImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = (evt) => {
                const doc = getActiveDoc();
                const pageObj = getMostVisiblePage(doc);
                
                const el = document.createElement('div');
                el.className = 'editor-element image-box';
                
                // Center
                const centerX = pageObj.width / 2 - 100;
                const centerY = pageObj.height / 2 - 100;

                el.style.left = centerX + 'px'; el.style.top = centerY + 'px';
                el.style.width = '200px'; el.style.height = '200px';
                el.style.backgroundImage = `url(${evt.target.result})`;
                pageObj.element.appendChild(el);
                enableDragAndSelect(el);
                selectElement(el);
                pushAction({ type: 'create', elements: [el], parent: pageObj.element });
            };
            reader.readAsDataURL(file);
        }

        // --- Page Manager ---
        function togglePageSidebar() {
            document.getElementById('page-sidebar').classList.toggle('open');
            renderPageList();
        }
        
        function renderPageList() {
            const list = document.getElementById('page-list');
            list.innerHTML = '';
            if(!activeDocId) return;
            const doc = getActiveDoc();
            
            doc.pages.forEach((p, idx) => {
                const div = document.createElement('div');
                div.className = 'page-thumb-item';
                div.innerHTML = `
                    <span class="font-bold text-sm">Page ${idx + 1}</span>
                    <div class="flex gap-1 text-gray-600">
                        <button onclick="rotatePage(${idx})" title="Rotate" class="p-1 hover:bg-gray-100 rounded"><i class="fa-solid fa-rotate-right"></i></button>
                        <button onclick="movePage(${idx}, -1)" title="Up" class="p-1 hover:bg-gray-100 rounded"><i class="fa-solid fa-arrow-up"></i></button>
                        <button onclick="movePage(${idx}, 1)" title="Down" class="p-1 hover:bg-gray-100 rounded"><i class="fa-solid fa-arrow-down"></i></button>
                        <button onclick="removePage(${idx})" title="Delete" class="text-red-500 p-1 hover:bg-red-50 rounded"><i class="fa-solid fa-trash"></i></button>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function rotatePage(idx) {
            const doc = getActiveDoc();
            const currentRot = doc.pageRotations[idx] || 0;
            doc.pageRotations[idx] = (currentRot + 90) % 360;
            
            // Update Visuals
            const pContainer = doc.pages[idx].element.parentElement;
            pContainer.style.transform = `rotate(${doc.pageRotations[idx]}deg)`;
            
            // Simple visual fix for margins to prevent overlap when rotated 90/270
            const rot = doc.pageRotations[idx];
            if (rot % 180 !== 0) {
                const diff = (doc.pages[idx].width - doc.pages[idx].height) / 2;
                pContainer.style.margin = `${diff}px 0`;
            } else {
                pContainer.style.margin = '0 0 20px 0';
            }
            saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
        }

        function movePage(idx, dir) {
            const doc = getActiveDoc();
            if(idx + dir < 0 || idx + dir >= doc.pages.length) return;
            
            // Swap in array
            const temp = doc.pages[idx];
            doc.pages[idx] = doc.pages[idx + dir];
            doc.pages[idx + dir] = temp;
            
            // Swap rotation metadata
            const r1 = doc.pageRotations[idx] || 0;
            const r2 = doc.pageRotations[idx+dir] || 0;
            doc.pageRotations[idx] = r2;
            doc.pageRotations[idx+dir] = r1;

            // Re-render DOM order
            doc.containerDiv.innerHTML = '';
            doc.pages.forEach(p => doc.containerDiv.appendChild(p.element.parentElement));
            
            renderPageList();
            saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
        }

        function removePage(idx) {
            pageToDeleteIdx = idx;
            document.getElementById('delete-confirm-modal').classList.remove('hidden');
        }
        
        function closeDeleteModal() {
            document.getElementById('delete-confirm-modal').classList.add('hidden');
            pageToDeleteIdx = null;
        }

        function executeDeletePage() {
            if(pageToDeleteIdx === null) return;
            const idx = pageToDeleteIdx;
            closeDeleteModal();
            
            const doc = getActiveDoc();
            const pObj = doc.pages[idx];
            pObj.element.parentElement.remove(); // Remove DOM
            doc.pages.splice(idx, 1);
            
            // Shift rotations
            const newRot = {};
            let newIdx = 0;
            for(let k in doc.pageRotations) {
                const ki = parseInt(k);
                if(ki === idx) continue;
                if(ki > idx) newRot[newIdx] = doc.pageRotations[ki];
                else newRot[ki] = doc.pageRotations[ki];
                if(ki > idx) newIdx++; 
            }
            doc.pageRotations = newRot;

            renderPageList();
            saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
        }

        // --- Canvas Interaction (Draggable, Magic) ---
        // (Similar to previous version but updated for new tools)
        function setupOverlayEvents(overlay, docObj) {
            let startX, startY;
            let currentDrawing = null;
            let isMagicDragging = false;
            let isDrawing = false;

            const startHandler = (e) => {
                if(e.target !== overlay) return;
                const pos = getEventPos(e);
                startX = pos.x - overlay.getBoundingClientRect().left;
                startY = pos.y - overlay.getBoundingClientRect().top;
                
                if(currentTool === 'cursor') return; 
                isDrawing = true;

                if (currentTool === 'magic') {
                    isMagicDragging = true;
                    magicBox = document.createElement('div');
                    magicBox.className = 'selection-box';
                    magicBox.style.left = startX + 'px'; magicBox.style.top = startY + 'px';
                    overlay.appendChild(magicBox);
                    return;
                }

                currentDrawing = document.createElement('div');
                currentDrawing.className = 'editor-element';
                currentDrawing.style.left = startX + 'px'; currentDrawing.style.top = startY + 'px';
                
                if(currentTool === 'whiteout') currentDrawing.classList.add('whiteout-box');
                else if(currentTool === 'highlight') currentDrawing.classList.add('highlight-box');
                else if(currentTool === 'box') currentDrawing.classList.add('shape-box');
                else if(currentTool === 'line') { currentDrawing.classList.add('shape-line'); currentDrawing.style.height = '1px'; }
                else if (currentTool === 'text') {
                    currentDrawing.classList.add('added-text');
                    currentDrawing.contentEditable = true; 
                    currentDrawing.style.fontSize = document.getElementById('font-size').value + 'px';
                    currentDrawing.style.color = document.getElementById('elem-color').value;
                    currentDrawing.style.fontFamily = FONT_MAP[document.getElementById('font-family').value].css;
                    currentDrawing.innerHTML = 'Type here';
                }
                overlay.appendChild(currentDrawing);
                selectElement(currentDrawing); 
            };

            const moveHandler = (e) => {
                if (!isDrawing && !isMagicDragging) return;
                const pos = getEventPos(e);
                const currX = pos.x - overlay.getBoundingClientRect().left;
                const currY = pos.y - overlay.getBoundingClientRect().top;
                const width = currX - startX;
                const height = currY - startY;

                if (currentTool === 'magic' && isMagicDragging && magicBox) {
                    const finalWidth = Math.abs(width);
                    const finalHeight = Math.abs(height);
                    magicBox.style.width = finalWidth + 'px';
                    magicBox.style.height = finalHeight + 'px';
                    magicBox.style.left = (width < 0 ? startX - finalWidth : startX) + 'px';
                    magicBox.style.top = (height < 0 ? startY - finalHeight : startY) + 'px';
                    return;
                }

                if(!currentDrawing) return;
                const finalWidth = Math.max(MIN_SIZE, Math.abs(width));
                const finalHeight = Math.max(MIN_SIZE, Math.abs(height));
                currentDrawing.style.width = finalWidth + 'px';
                currentDrawing.style.height = finalHeight + 'px';
                currentDrawing.style.left = (width < 0 ? startX - finalWidth : startX) + 'px';
                currentDrawing.style.top = (height < 0 ? startY - finalHeight : startY) + 'px';
                
                if(currentTool === 'line') { currentDrawing.style.height = '1px'; currentDrawing.style.top = startY + 'px'; }
            };

            const endHandler = () => {
                isDrawing = false;
                if (currentTool === 'magic' && magicBox) {
                    // ... Magic text logic (abbreviated for brevity, reusing existing)
                     const rect = { x: parseInt(magicBox.style.left), y: parseInt(magicBox.style.top), w: parseInt(magicBox.style.width), h: parseInt(magicBox.style.height) };
                    magicBox.remove(); magicBox = null; isMagicDragging = false;
                    const isClick = rect.w < 15 && rect.h < 15;
                    if (isClick) { rect.x -= 5; rect.y -= 5; rect.w = 10; rect.h = 10; }
                    const pageObj = docObj.pages.find(p => p.element === overlay);
                    if(pageObj) processMagicSelection(rect, pageObj.textContent, pageObj.viewport, overlay);
                    return;
                }

                if(currentDrawing) {
                    const el = currentDrawing;
                    let isValid = true;
                    if(currentTool === 'line') { if(el.offsetWidth < 5) isValid = false; } 
                    else if (currentTool === 'text') { isValid = true; } 
                    else { if(el.offsetWidth < MIN_SIZE || el.offsetHeight < MIN_SIZE) isValid = false; }

                    if(!isValid) { el.remove(); selectedElement = null; } 
                    else {
                        if(currentTool === 'box') el.style.borderColor = document.getElementById('elem-color').value;
                        else if(currentTool === 'line') el.style.backgroundColor = document.getElementById('elem-color').value;
                        enableDragAndSelect(el); selectElement(el); 
                        pushAction({ type: 'create', elements: [el], parent: overlay });
                        if(currentTool === 'text') { setupTextEditing(el); setTimeout(() => { el.focus(); }, 10); }
                    }
                    currentDrawing = null; setTool('cursor'); 
                }
            };

            overlay.addEventListener('mousedown', startHandler);
            overlay.addEventListener('touchstart', startHandler);
            window.addEventListener('mousemove', moveHandler); // Window to catch drags outside
            window.addEventListener('touchmove', moveHandler, { passive: false });
            window.addEventListener('mouseup', endHandler);
            window.addEventListener('touchend', endHandler);
        }

        // --- Helper Functions (Abbreviated, similar to before) ---
        function selectElement(el) {
            if (selectedElement && selectedElement !== el) deselectAll();
            selectedElement = el;
            el.classList.add('selected');
            if (!el.querySelector('.resize-handle')) addResizingHandles(el);
            
            if(el.classList.contains('added-text')) {
                // Restore props to UI
                document.getElementById('font-size').value = parseInt(el.style.fontSize) || 12;
                document.getElementById('elem-color').value = rgbToHex(el.style.color);
                
                // Find font key
                let foundKey = 'Helvetica';
                const currentFont = el.style.fontFamily;
                for(const [key, val] of Object.entries(FONT_MAP)) {
                    if(currentFont.includes(val.css.split(',')[0])) foundKey = key;
                }
                document.getElementById('font-family').value = foundKey;
                checkSelectionState();
            }
        }
        function deselectAll() {
            if (selectedElement) {
                selectedElement.classList.remove('selected');
                selectedElement.classList.remove('is-editing');
                if(selectedElement.blur) selectedElement.blur();
            }
            selectedElement = null;
        }
        
        // --- UPDATED Drag Logic for Text Editing Fix ---
        function enableDragAndSelect(el) {
            let isDragging = false; let offset = [0,0]; let startState = null;
            
            // Helper to check edit state
            const isTextEditing = () => el.classList.contains('added-text') && el.classList.contains('is-editing');

            const startDrag = (e) => {
                if(e.target.classList.contains('resize-handle') || currentTool !== 'cursor') return;
                
                // FIX: If we are editing text, let the click through to select text, do NOT start dragging
                if (isTextEditing()) {
                    e.stopPropagation(); 
                    return; 
                }

                e.stopPropagation(); 
                
                // Only prevent default if NOT editing to stop text cursor flickering on non-text elements
                if(e.type === 'mousedown') e.preventDefault();
                
                selectElement(el); 
                isDragging=true;
                
                // Visual feedback during drag
                el.classList.add('dragging');
                
                const pos = getEventPos(e); offset=[el.offsetLeft-pos.x, el.offsetTop-pos.y];
                startState = { left: el.style.left, top: el.style.top, width: el.style.width, height: el.style.height };
            };
            const drag = (e) => {
                if(!isDragging) return; e.preventDefault();
                const pos = getEventPos(e); el.style.left = (pos.x+offset[0])+'px'; el.style.top = (pos.y+offset[1])+'px';
            };
            const endDrag = () => { 
                if(isDragging) {
                    el.classList.remove('dragging');
                    // Logic to handle dragging between pages
                    const elRect = el.getBoundingClientRect();
                    const elCenterX = elRect.left + elRect.width/2;
                    const elCenterY = elRect.top + elRect.height/2;
                    
                    const doc = getActiveDoc();
                    let newParent = null;
                    let bestPage = null;
                    
                    const overlays = Array.from(document.querySelectorAll('.page-overlay'));
                    
                    for(const ov of overlays) {
                         if(ov === el.parentElement) continue;
                         const r = ov.getBoundingClientRect();
                         if(elCenterX >= r.left && elCenterX <= r.right && elCenterY >= r.top && elCenterY <= r.bottom) {
                             newParent = ov;
                             bestPage = doc.pages.find(p => p.element === ov);
                             break;
                         }
                    }
                    
                    if(newParent && bestPage) {
                        const oldRect = el.getBoundingClientRect();
                        const newParentRect = newParent.getBoundingClientRect();
                        const newLeft = oldRect.left - newParentRect.left;
                        const newTop = oldRect.top - newParentRect.top;
                        newParent.appendChild(el);
                        el.style.left = newLeft + 'px';
                        el.style.top = newTop + 'px';
                    }

                    if(startState) pushAction({ type: 'move_resize', element: el, start: startState, end: { left: el.style.left, top: el.style.top, width: el.style.width, height: el.style.height } });
                }
                isDragging=false; 
            };
            el.addEventListener('mousedown', startDrag); el.addEventListener('touchstart', startDrag);
            window.addEventListener('mousemove', drag); window.addEventListener('touchmove', drag, {passive:false});
            window.addEventListener('mouseup', endDrag); window.addEventListener('touchend', endDrag);
        }
        
        function addResizingHandles(el) {
            el.querySelectorAll('.resize-handle').forEach(h => h.remove());
            ['tl','tr','bl','br'].forEach(pos => {
                const h = document.createElement('div'); h.className=`resize-handle ${pos}`;
                if(pos.includes('t')) h.style.top='-6px'; if(pos.includes('b')) h.style.bottom='-6px';
                if(pos.includes('l')) h.style.left='-6px'; if(pos.includes('r')) h.style.right='-6px';
                
                // FIX: Inline styles for cursor often work best for these dynamic handles
                if(pos==='tl' || pos==='br') h.style.cursor = 'nwse-resize';
                else h.style.cursor = 'nesw-resize';

                h.dataset.position=pos; el.appendChild(h);
                const startR=(e)=>{
                    e.stopPropagation(); e.preventDefault();
                    let isResizing=true; const startP=getEventPos(e);
                    const startDim={w:el.offsetWidth,h:el.offsetHeight,l:el.offsetLeft,t:el.offsetTop};
                    const moveR=(ev)=>{
                        if(!isResizing) return; ev.preventDefault();
                        const curP=getEventPos(ev); const dx=curP.x-startP.x; const dy=curP.y-startP.y;
                        let nw=startDim.w, nh=startDim.h, nl=startDim.l, nt=startDim.t;
                        if(pos.includes('l')) { nw-=dx; nl+=dx; } else nw+=dx;
                        if(pos.includes('t')) { nh-=dy; nt+=dy; } else nh+=dy;
                        if(nw>20) { el.style.width=nw+'px'; if(pos.includes('l')) el.style.left=nl+'px'; }
                        if(nh>20) { el.style.height=nh+'px'; if(pos.includes('t')) el.style.top=nt+'px'; }
                    };
                    const stopR=()=>{isResizing=false; window.removeEventListener('mousemove',moveR); window.removeEventListener('touchmove',moveR); window.removeEventListener('mouseup',stopR); window.removeEventListener('touchend',stopR);};
                    window.addEventListener('mousemove',moveR); window.addEventListener('touchmove',moveR,{passive:false});
                    window.addEventListener('mouseup',stopR); window.addEventListener('touchend',stopR);
                };
                h.addEventListener('mousedown',startR); h.addEventListener('touchstart',startR);
            });
        }

        // --- PDF Generation (Updated for Pages/Images/Highlights) ---
        async function saveCurrentDoc() {
            if(!activeDocId) return;
            const doc = getActiveDoc();
            showLoader(true, "Generating PDF...");
            try {
                // 1. Load Original
                const originalPdf = await PDFLib.PDFDocument.load(doc.fileBytes);
                // 2. Create New Doc
                const newPdf = await PDFLib.PDFDocument.create();
                
                // Embed Fonts & Images
                const helvetica = await newPdf.embedFont(PDFLib.StandardFonts.Helvetica);
                const helveticaBold = await newPdf.embedFont(PDFLib.StandardFonts.HelveticaBold);
                
                // 3. Process Pages (Based on current doc.pages Array Order)
                const originalIndices = doc.pages.map(p => p.originalIndex); // Get map of current order to original index
                const copiedPages = await newPdf.copyPages(originalPdf, originalIndices);

                for(let i=0; i < doc.pages.length; i++) {
                    const pObj = doc.pages[i];
                    const pdfPage = copiedPages[i];
                    newPdf.addPage(pdfPage);
                    
                    // Rotation
                    const rot = doc.pageRotations[i] || 0;
                    pdfPage.setRotation(PDFLib.degrees(rot));
                    
                    const { width, height } = pdfPage.getSize();
                    const scale = doc.scale;
                    
                    // Get Elements
                    const elements = Array.from(pObj.element.children).filter(el => el.classList.contains('editor-element'));
                    
                    for (const el of elements) {
                        const style = window.getComputedStyle(el);
                        const left = parseFloat(style.left) / scale; 
                        const top = parseFloat(style.top) / scale;
                        const elWidth = parseFloat(style.width) / scale;
                        const elHeight = parseFloat(style.height) / scale;
                        const pdfY = height - top - elHeight;

                        if(el.classList.contains('added-text')) {
                            const fontSize = parseFloat(style.fontSize) / scale;
                            // Parse Color properly
                            const rgb = parseColorString(style.color);
                            const color = PDFLib.rgb(rgb.r/255, rgb.g/255, rgb.b/255);
                            pdfPage.drawText(el.innerText, { x: left, y: pdfY + elHeight - fontSize + (fontSize * 0.1), size: fontSize, font: helvetica, color: color });
                        }
                        else if(el.classList.contains('image-box') || el.classList.contains('signature-box')) {
                            const bgUrl = el.style.backgroundImage.slice(5, -2);
                            let img;
                            if(bgUrl.startsWith('data:image/png')) img = await newPdf.embedPng(bgUrl);
                            else if(bgUrl.startsWith('data:image/jpeg')) img = await newPdf.embedJpg(bgUrl);
                            
                            if(img) {
                                pdfPage.drawImage(img, { x: left, y: pdfY, width: elWidth, height: elHeight });
                            }
                        }
                        else if(el.classList.contains('highlight-box')) {
                            pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, color: PDFLib.rgb(1, 1, 0), opacity: 0.5 });
                        }
                        else if(el.classList.contains('whiteout-box')) {
                            pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, color: PDFLib.rgb(1, 1, 1) });
                        }
                        else if(el.classList.contains('shape-box')) {
                            pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, borderColor: PDFLib.rgb(0,0,0), borderWidth: 2/scale, opacity: 0 });
                        }
                    }
                }

                const pdfBytes = await newPdf.save();
                const blob = new Blob([pdfBytes], { type: "application/pdf" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "edited_" + doc.name;
                link.click();
            } catch(e) { console.error(e); alert("Save failed: " + e.message); } finally { showLoader(false); }
        }

        // --- Restored Utils ---
        function renderTabs() {
            const bar = document.getElementById('tab-bar');
            bar.innerHTML = '';
            if(documents.length === 0) { bar.innerHTML = '<div class="px-4 py-2 text-sm text-gray-500 italic">No document open</div>'; return; }
            documents.forEach(doc => {
                const isActive = doc.id === activeDocId;
                const tab = document.createElement('div');
                tab.className = `tab-item px-4 py-2 text-sm cursor-pointer flex items-center gap-2 border-r border-gray-300 ${isActive ? 'active' : 'bg-gray-100 text-gray-600 hover:bg-gray-50'}`;
                tab.innerHTML = `<span class="truncate max-w-[120px]">${doc.name}</span><button class="hover:text-red-500 rounded-full p-0.5" onclick="closeDocument(event, '${doc.id}')"><i class="fa-solid fa-xmark"></i></button>`;
                tab.onclick = () => setActiveDocument(doc.id);
                bar.appendChild(tab);
            });
        }

        function closeDocument(e, id) {
            e.stopPropagation();
            deleteDocFromDB(id);
            documents = documents.filter(d => d.id !== id);
            if(documents.length === 0) {
                activeDocId = null;
                document.getElementById('empty-state').classList.remove('hidden');
                document.getElementById('workspace-wrapper').classList.add('hidden');
            } else if (activeDocId === id) setActiveDocument(documents[documents.length - 1].id);
            else renderTabs();
        }

        function parseColorString(colorStr) {
            if (!colorStr) return { r: 0, g: 0, b: 0 };
            if (colorStr.trim().startsWith('rgb')) {
                const parts = colorStr.match(/\d+/g);
                if (parts && parts.length >= 3) return { r: parseInt(parts[0]), g: parseInt(parts[1]), b: parseInt(parts[2]) };
            }
            if (colorStr.startsWith('#')) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(colorStr);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 0, g: 0, b: 0 };
            }
            return { r: 0, g: 0, b: 0 };
        }
        
        function rgbToHex(col) { 
             const c = parseColorString(col);
             return "#" + ((1 << 24) + (c.r << 16) + (c.g << 8) + c.b).toString(16).slice(1);
        }

        function changeZoom(delta) {
            if(!activeDocId) return;
            const doc = getActiveDoc();
            doc.scale = parseFloat((doc.scale + delta).toFixed(1));
            if(doc.scale < 0.5) doc.scale = 0.5; if(doc.scale > 3.0) doc.scale = 3.0;
            doc.containerDiv.style.transform = `scale(${doc.scale})`;
            document.getElementById('zoom-label').innerText = Math.round(doc.scale * 100) + '%';
            saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
        }

        function processMagicSelection(rect, textContent, viewport, overlay) {
            let matches = [];
            for (const item of textContent.items) {
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                const vx = tx[4]; const vy = tx[5]; 
                const fontSize = Math.sqrt(tx[2]*tx[2] + tx[3]*tx[3]); 
                const realWidth = item.width * Math.sqrt(tx[0]*tx[0] + tx[1]*tx[1]); 
                const tLeft = vx; const tTop = vy - fontSize; const tRight = vx + realWidth; const tBottom = vy;
                const intersects = !(rect.x > tRight || (rect.x + rect.w) < tLeft || rect.y > tBottom || (rect.y + rect.h) < tTop);
                if (intersects && item.str.trim().length > 0 && realWidth > 0) {
                    matches.push({ str: item.str, x: tLeft, y: tTop, w: realWidth, h: fontSize, r: tRight, b: tBottom });
                }
            }
            
            if (matches.length === 0) return;

            let avgFontSize = 0; matches.forEach(m => avgFontSize += m.h); avgFontSize = avgFontSize / matches.length;
            matches.sort((a, b) => (Math.abs(a.y - b.y) > (avgFontSize / 2)) ? a.y - b.y : a.x - b.x);

            let combinedText = ""; let lastY = matches[0].y;
            matches.forEach((m, i) => {
                if (Math.abs(m.y - lastY) > (avgFontSize * 1.5) && i > 0) combinedText += "\n";
                else if (i > 0) combinedText += " ";
                combinedText += m.str; lastY = m.y;
            });

            const boxX = rect.x; const boxY = rect.y; const boxW = rect.w; const boxH = rect.h;
            let bgColor = 'white';
            try {
                const canvas = overlay.parentElement.querySelector('canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    const sampleX = Math.max(0, boxX - 5); const sampleY = Math.max(0, boxY - 5);
                    const p = ctx.getImageData(sampleX, sampleY, 1, 1).data;
                    bgColor = `rgb(${p[0]}, ${p[1]}, ${p[2]})`;
                }
            } catch(e) { console.log("Bg Sample Fail", e); }

            const newText = document.createElement('div');
            newText.className = 'editor-element added-text';
            newText.contentEditable = true;
            newText.style.left = boxX + 'px';
            newText.style.top = boxY + 'px'; 
            newText.style.width = boxW + 'px'; 
            newText.style.fontSize = Math.round(avgFontSize) + 'px';
            newText.style.color = '#000000';
            newText.style.fontFamily = FONT_MAP['Helvetica'].css;

            newText.style.whiteSpace = 'normal'; 
            newText.innerText = combinedText;
            overlay.appendChild(newText);
            
            const whiteout = document.createElement('div');
            whiteout.className = 'editor-element whiteout-box';
            whiteout.style.left = boxX + 'px'; whiteout.style.top = boxY + 'px';
            whiteout.style.width = boxW + 'px'; whiteout.style.height = boxH + 'px';
            whiteout.style.backgroundColor = bgColor; 
            overlay.insertBefore(whiteout, newText);

            setupTextEditing(newText);
            enableDragAndSelect(newText);
            enableDragAndSelect(whiteout);
            pushAction({ type: 'create', elements: [whiteout, newText], parent: overlay });
        }

        function setupTextEditing(el) {
            el.addEventListener('dblclick', (e) => { e.stopPropagation(); el.focus(); el.classList.add('is-editing'); });
            let lastTap = 0;
            el.addEventListener('touchstart', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                if (tapLength < 500 && tapLength > 0) { e.stopPropagation(); el.focus(); el.classList.add('is-editing'); }
                lastTap = currentTime;
            });

            el.addEventListener('blur', () => { 
                el.classList.remove('is-editing');
                if(activeDocId) { const doc = getActiveDoc(); saveStateToDB(doc.id, serializeDocState(doc), doc.scale); }
            });
            el.addEventListener('focus', () => { el.classList.add('is-editing'); checkSelectionState(); });
        }

        function showLoader(show, text="Processing...") { document.getElementById('loader-overlay').classList.toggle('hidden', !show); }
        
        function updateSelectedProp(type) {
            if(!selectedElement) return;
            let val = '';
            if (type === 'size') val = document.getElementById('font-size').value;
            else if (type === 'color') val = document.getElementById('elem-color').value;
            else if (type === 'font') val = document.getElementById('font-family').value;
            
            const oldVal = (type === 'size') ? selectedElement.style.fontSize : 
                          (type === 'color') ? selectedElement.style.color :
                          (type === 'font') ? { css: selectedElement.style.fontFamily, key: selectedElement.dataset.fontKey } : '';

            if(selectedElement.classList.contains('added-text')) {
                if(type === 'color') selectedElement.style.color = val;
                if(type === 'size') selectedElement.style.fontSize = val + 'px';
                if(type === 'font') {
                    selectedElement.style.fontFamily = FONT_MAP[val].css;
                    selectedElement.dataset.fontKey = val;
                }
            } else {
                if(type === 'color') {
                    if(selectedElement.classList.contains('shape-box')) selectedElement.style.borderColor = val;
                    else if(selectedElement.classList.contains('shape-line')) selectedElement.style.backgroundColor = val;
                }
            }
            
            let newVal = val;
            if (type === 'font') newVal = { css: FONT_MAP[val].css, key: val };

            pushAction({ type: 'style', element: selectedElement, prop: type, oldVal: oldVal, newVal: newVal });
        }
        
        function deleteSelected() { if(selectedElement) { 
            const p = selectedElement.parentElement;
            pushAction({ type: 'delete', elements: [selectedElement], parent: p });
            selectedElement.remove(); selectedElement=null; 
        } }
        
        function toggleBold() {
            if (!selectedElement || !selectedElement.classList.contains('added-text')) return;
            const current = selectedElement.style.fontWeight;
            const newVal = (current === 'bold' || parseInt(current) >= 700) ? 'normal' : 'bold';
            selectedElement.style.fontWeight = newVal;
            pushAction({ type: 'style', element: selectedElement, prop: 'bold', oldVal: current, newVal: newVal });
            checkSelectionState();
        }

        function checkSelectionState() {
            if (!selectedElement || !selectedElement.classList.contains('added-text')) return;
            const isBold = (selectedElement.style.fontWeight === 'bold' || parseInt(selectedElement.style.fontWeight) >= 700);
            if(isBold) document.getElementById('btn-bold').classList.add('bg-gray-200');
            else document.getElementById('btn-bold').classList.remove('bg-gray-200');
        }

    </script>
</body>
</html>