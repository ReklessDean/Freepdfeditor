<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro PDF Editor Suite</title>
    <link rel="icon" type="image/png" href="logo.png">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@0.0.4/dist/fontkit.umd.min.js"></script>
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        body { font-family: 'Inter', sans-serif; background-color: #1e1e1e; overflow: hidden; }
        
        /* Layout Grid */
        #app-container {
            display: grid;
            grid-template-rows: 60px 40px 1fr;
            height: 100vh;
        }

        /* Workspace */
        #pdf-workspace {
            overflow: auto;
            background-color: #525659;
            position: relative;
            height: 100%;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pdf-page-container {
            position: relative;
            margin-bottom: 30px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            background: white;
            transform-origin: top left;
        }

        /* Overlay & Elements */
        .page-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: all; 
            overflow: hidden;
            z-index: 10;
        }

        /* Custom Elements Common */
        .editor-element {
            position: absolute;
            user-select: none; 
            box-sizing: border-box;
            touch-action: none; 
            min-width: 5px; 
            min-height: 1px; 
        }
        .editor-element:hover { outline: 1px dashed #3b82f6; }
        
        /* Selected State - Highest Z-Index when selected */
        .editor-element.selected { 
            outline: 2px solid #2563eb; 
            z-index: 100 !important; 
            cursor: move; 
        }
        
        /* Layering Strategy:
           10: Whiteout (Bottom)
           20: Shapes/Lines
           30: Text (Top)
        */

        .whiteout-box { 
            /* background-color set dynamically now, default white */
            background-color: white;
            border: none; 
            z-index: 10; 
        } 
        
        .shape-box { 
            border: 2px solid #000; 
            background: transparent; 
            z-index: 20;
        }
        
        .shape-line { 
            background-color: #000; 
            z-index: 20;
        }

        /* Specific Elements */
        .added-text {
            font-family: Helvetica, sans-serif; 
            color: #000;
            line-height: 1.2;
            padding: 2px 4px; 
            white-space: normal; 
            word-break: break-word; 
            overflow: hidden; 
            cursor: default;
            background: transparent;
            z-index: 30; /* Always on top of whiteout */
        }
        
        .added-text:hover {
            background-color: rgba(59, 130, 246, 0.05); 
        }
        
        /* Editing State */
        .added-text.selected.is-editing {
            outline: 2px solid #ef4444; 
            cursor: text !important; 
            user-select: text !important; 
            -webkit-user-select: text !important;
        }

        /* Magic Text Highlight */
        .magic-highlight {
            position: absolute;
            background-color: rgba(59, 130, 246, 0.2);
            border: 1px solid #3b82f6;
            cursor: pointer;
            z-index: 5;
            pointer-events: none; 
        }

        /* Magic Selection Box */
        .selection-box {
            position: absolute;
            border: 1px dashed #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
            z-index: 100;
            pointer-events: none;
        }
        
        /* Resizing Handles */
        .resize-handle {
            position: absolute;
            z-index: 110; /* Above selected element */
            touch-action: none;
            display: none; 
            width: 10px;
            height: 10px;
            background-color: #3b82f6;
            border: 1px solid white;
            border-radius: 50%;
        }
        .editor-element.selected .resize-handle {
            display: block;
        }

        /* Guides */
        .guide-line {
            background-color: #06b6d4; 
            pointer-events: all;
            z-index: 200; /* Above everything */
            border: none !important; 
            outline: none !important;
            opacity: 0.5; 
            transition: background-color 0.1s;
        }
        .guide-line.selected {
            background-color: #ef4444; 
            opacity: 1;
        }

        .guide-horizontal {
            height: 0.5px; 
            min-height: 0.5px;
            width: 100%;
            left: 0;
            cursor: ns-resize;
        }
        .guide-vertical {
            width: 0.5px; 
            min-width: 0.5px;
            height: 100%;
            top: 0;
            cursor: ew-resize;
        }

        /* Tools Active State */
        .tool-btn { position: relative; }
        .tool-btn.active {
            background-color: #e0f2fe;
            color: #0284c7;
            border-color: #0284c7;
        }

        /* Tabs & Loader styles */
        .tab-item { user-select: none; max-width: 200px; }
        .tab-item.active { background-color: #525659; color: white; border-bottom: 2px solid #60a5fa; }
        .dropdown-menu { display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #e5e5e5; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); border-radius: 6px; z-index: 100; min-width: 150px; padding: 4px; }
        .dropdown-menu.show { display: block; }
        .loader { border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #3498db; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="app-container">
        
        <!-- Header / Toolbar -->
        <header class="bg-white border-b border-gray-200 flex items-center justify-between px-4 z-50 shadow-sm">
            <div class="flex items-center gap-4">
                <div class="flex items-center gap-2 text-gray-700 font-bold text-lg select-none">
                    <div class="bg-red-600 text-white p-1 rounded-md text-sm"><i class="fa-solid fa-file-pdf"></i></div>
                    <span class="hidden md:inline">PDF Studio</span>
                </div>
                
                <div class="h-6 w-px bg-gray-300 mx-2"></div>
                
                <!-- History Tools -->
                <div class="flex items-center gap-1">
                    <button onclick="performUndo()" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Undo (Ctrl+Z)">
                        <i class="fa-solid fa-rotate-left"></i>
                    </button>
                    <button onclick="performRedo()" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Redo (Ctrl+Y)">
                        <i class="fa-solid fa-rotate-right"></i>
                    </button>
                </div>

                <div class="h-6 w-px bg-gray-300 mx-2"></div>

                <!-- Main Tools -->
                <div id="main-tools" class="flex items-center gap-1">
                    <button onclick="setTool('cursor')" id="btn-cursor" class="tool-btn active p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Select / Move / Resize">
                        <i class="fa-solid fa-arrow-pointer"></i>
                    </button>
                    
                    <button onclick="setTool('text')" id="btn-text" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Draw Text Box">
                        <i class="fa-solid fa-font"></i>
                    </button>
                    
                    <!-- Guides Dropdown -->
                    <div class="relative">
                        <button onclick="toggleDropdown('guides-menu')" id="btn-guide" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition flex items-center gap-1" title="Insert Guide">
                            <i class="fa-solid fa-ruler-combined"></i> <i class="fa-solid fa-caret-down text-xs"></i>
                        </button>
                        <div id="guides-menu" class="dropdown-menu">
                            <div onclick="setTool('guide-h')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-ruler-horizontal"></i> H. Guide
                            </div>
                            <div onclick="setTool('guide-v')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-ruler-vertical"></i> V. Guide
                            </div>
                        </div>
                    </div>

                    <button onclick="setTool('whiteout')" id="btn-whiteout" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Whiteout / Eraser">
                        <i class="fa-solid fa-eraser"></i>
                    </button>

                    <!-- Shapes Dropdown -->
                    <div class="relative">
                        <button onclick="toggleDropdown('shapes-menu')" id="btn-shape" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition flex items-center gap-1" title="Insert Shape">
                            <i class="fa-solid fa-shapes"></i> <i class="fa-solid fa-caret-down text-xs"></i>
                        </button>
                        <div id="shapes-menu" class="dropdown-menu">
                            <div onclick="setTool('line')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-solid fa-minus"></i> Line
                            </div>
                            <div onclick="setTool('box')" class="p-2 hover:bg-gray-100 rounded cursor-pointer flex items-center gap-2">
                                <i class="fa-regular fa-square"></i> Rectangle
                            </div>
                        </div>
                    </div>

                    <!-- Magic Wand -->
                    <button onclick="setTool('magic')" id="btn-magic" class="tool-btn p-2 rounded hover:bg-gray-100 text-gray-600 transition" title="Edit Existing Text (Magic Wand)">
                        <i class="fa-solid fa-wand-magic-sparkles"></i>
                    </button>
                </div>

                <div class="h-6 w-px bg-gray-300 mx-2"></div>

                <!-- Properties -->
                <div class="flex items-center gap-2" id="properties-panel">
                    <!-- Font Size -->
                    <select id="font-size" onchange="updateSelectedProp('size')" class="h-8 text-sm border border-gray-300 rounded px-1 bg-gray-50 hover:bg-white focus:outline-none">
                        <option value="10">10 pt</option>
                        <option value="12" selected>12 pt</option>
                        <option value="14">14 pt</option>
                        <option value="18">18 pt</option>
                        <option value="24">24 pt</option>
                        <option value="36">36 pt</option>
                    </select>
                    
                    <!-- Bold -->
                    <button id="btn-bold" onmousedown="event.preventDefault()" onclick="toggleBold()" class="h-8 w-8 rounded hover:bg-gray-200 text-gray-600 font-bold text-lg" title="Bold (Ctrl/Cmd + B)">
                        B
                    </button>
                    
                    <!-- Color -->
                    <div class="relative w-8 h-8 rounded border border-gray-300 cursor-pointer overflow-hidden" title="Color">
                        <input type="color" id="elem-color" oninput="updateSelectedProp('color')" class="absolute -top-4 -left-4 w-16 h-16 cursor-pointer" value="#000000">
                    </div>

                    <button onclick="deleteSelected()" class="p-2 rounded hover:bg-red-100 text-gray-500 hover:text-red-600 transition" title="Delete Selected (Del)">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
            </div>

            <!-- Right Side Actions -->
            <div class="flex items-center gap-3">
                <button onclick="document.getElementById('file-upload').click()" class="text-sm font-medium text-gray-600 hover:text-blue-600 flex items-center gap-2">
                    <i class="fa-solid fa-folder-plus"></i> Open New
                </button>
                <button onclick="saveCurrentDoc()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-1.5 rounded shadow-sm text-sm font-medium flex items-center gap-2 transition">
                    <i class="fa-solid fa-download"></i> Save PDF
                </button>
            </div>
        </header>

        <!-- Tab Bar -->
        <div class="bg-gray-200 border-b border-gray-300 flex items-end px-2 gap-1 overflow-x-auto h-full" id="tab-bar">
            <!-- Tabs or loading state -->
        </div>

        <!-- Main Content -->
        <main class="relative overflow-hidden">
            <input type="file" id="file-upload" accept="application/pdf" class="hidden" onchange="handleFileSelect(event)">

            <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-100 text-gray-500 z-0">
                <div class="w-24 h-24 bg-gray-200 rounded-full flex items-center justify-center mb-4">
                    <i class="fa-regular fa-file-pdf text-4xl text-gray-400"></i>
                </div>
                <h2 class="text-xl font-semibold text-gray-700">No Document Open</h2>
                <p class="mb-6">Upload a PDF to start editing</p>
                <button onclick="document.getElementById('file-upload').click()" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition shadow">
                    Select PDF File
                </button>
            </div>

            <div id="workspace-wrapper" class="hidden w-full h-full relative">
                <div class="absolute bottom-6 right-6 z-50 bg-white rounded-lg shadow-lg border border-gray-200 flex flex-col overflow-hidden">
                    <button onclick="changeZoom(0.1)" class="p-2 hover:bg-gray-100 border-b border-gray-100"><i class="fa-solid fa-plus"></i></button>
                    <span id="zoom-label" class="text-xs text-center py-1 font-mono text-gray-500">100%</span>
                    <button onclick="changeZoom(-0.1)" class="p-2 hover:bg-gray-100"><i class="fa-solid fa-minus"></i></button>
                </div>
                <!-- Deselection happens on clicking this background -->
                <div id="pdf-workspace" onclick="handleWorkspaceClick(event)"></div>
            </div>

            <div id="loader-overlay" class="hidden absolute inset-0 z-[100] bg-black/50 flex flex-col items-center justify-center text-white">
                <div class="loader mb-3"></div>
                <span id="loader-text">Processing...</span>
            </div>
        </main>
    </div>

    <script>
        // --- IndexedDB Persistence Layer ---
        const DB_NAME = 'PDFEditorDB';
        const DB_VERSION = 1;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('files')) {
                        db.createObjectStore('files', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('state')) {
                        db.createObjectStore('state', { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e);
            });
        }

        async function saveFileToDB(docId, name, arrayBuffer) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['files'], 'readwrite');
                const store = tx.objectStore('files');
                store.put({ id: docId, name: name, data: arrayBuffer });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function saveStateToDB(docId, pagesData, scale) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['state'], 'readwrite');
                const store = tx.objectStore('state');
                store.put({ id: docId, pages: pagesData, scale: scale, lastModified: Date.now() });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function loadAllFromDB() {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['files', 'state'], 'readonly');
                const filesStore = tx.objectStore('files');
                const stateStore = tx.objectStore('state');
                
                const filesReq = filesStore.getAll();
                const stateReq = stateStore.getAll();

                tx.oncomplete = () => {
                    const files = filesReq.result;
                    const states = stateReq.result;
                    // Merge
                    const docs = files.map(f => {
                        const s = states.find(st => st.id === f.id);
                        return { ...f, state: s || null };
                    });
                    resolve(docs);
                };
                tx.onerror = () => reject(tx.error);
            });
        }

        async function deleteDocFromDB(docId) {
            const db = await initDB();
            const tx = db.transaction(['files', 'state'], 'readwrite');
            tx.objectStore('files').delete(docId);
            tx.objectStore('state').delete(docId);
        }

        // --- Core Application State ---
        let documents = []; 
        let activeDocId = null;
        let currentTool = 'cursor';
        let selectedElement = null;
        let savedRange = null; 
        
        let SNAP_THRESHOLD = 10; 
        let MIN_SIZE = 20; 

        // --- History / Undo / Redo ---
        const historyStack = [];
        const redoStack = [];

        function pushAction(action) {
            historyStack.push(action);
            redoStack.length = 0; 
            
            // Auto-Save State Trigger
            if(activeDocId) {
                const doc = getActiveDoc();
                const serialized = serializeDocState(doc);
                saveStateToDB(doc.id, serialized, doc.scale);
            }
        }

        function serializeDocState(doc) {
            const pagesState = {};
            doc.pages.forEach(p => {
                const elements = Array.from(p.element.children).filter(el => el.classList.contains('editor-element'));
                pagesState[p.pageNum] = elements.map(el => {
                    const style = el.style;
                    return {
                        classList: Array.from(el.classList).join(' '),
                        style: {
                            left: style.left, top: style.top, width: style.width, height: style.height,
                            fontSize: style.fontSize, color: style.color, 
                            borderColor: style.borderColor, backgroundColor: style.backgroundColor,
                            fontWeight: style.fontWeight
                        },
                        innerHTML: el.innerHTML,
                        dataset: { ...el.dataset }
                    };
                });
            });
            return pagesState;
        }

        function performUndo() {
            if (historyStack.length === 0) return;
            const action = historyStack.pop();
            redoStack.push(action);
            applyActionUndo(action);
            if(activeDocId) {
                const doc = getActiveDoc();
                saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
            }
        }

        function performRedo() {
            if (redoStack.length === 0) return;
            const action = redoStack.pop();
            historyStack.push(action);
            applyActionRedo(action);
            if(activeDocId) {
                const doc = getActiveDoc();
                saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
            }
        }

        function applyActionUndo(action) {
            switch (action.type) {
                case 'create':
                    action.elements.forEach(el => el.remove());
                    deselectAll();
                    break;
                case 'delete':
                    action.elements.forEach(el => {
                        action.parent.appendChild(el);
                        enableDragAndSelect(el);
                        if(el.classList.contains('added-text')) setupTextEditing(el);
                    });
                    break;
                case 'move_resize':
                    const el = action.element;
                    el.style.left = action.start.left;
                    el.style.top = action.start.top;
                    el.style.width = action.start.width;
                    el.style.height = action.start.height;
                    break;
                case 'content':
                    action.element.innerHTML = action.oldContent;
                    break;
                case 'style':
                    if (action.prop === 'bold') action.element.style.fontWeight = action.oldVal;
                    else if (action.prop === 'color') {
                         if (action.element.classList.contains('shape-box')) action.element.style.borderColor = action.oldVal;
                         else if (action.element.classList.contains('shape-line')) action.element.style.backgroundColor = action.oldVal;
                         else action.element.style.color = action.oldVal;
                    } else if (action.prop === 'size') {
                        action.element.style.fontSize = action.oldVal;
                    }
                    break;
            }
        }

        function applyActionRedo(action) {
            switch (action.type) {
                case 'create':
                    action.elements.forEach(el => {
                        action.parent.appendChild(el);
                        enableDragAndSelect(el);
                        if(el.classList.contains('added-text')) setupTextEditing(el);
                    });
                    break;
                case 'delete':
                    action.elements.forEach(el => el.remove());
                    deselectAll();
                    break;
                case 'move_resize':
                    const el = action.element;
                    el.style.left = action.end.left;
                    el.style.top = action.end.top;
                    el.style.width = action.end.width;
                    el.style.height = action.end.height;
                    break;
                case 'content':
                    action.element.innerHTML = action.newContent;
                    break;
                case 'style':
                     if (action.prop === 'bold') action.element.style.fontWeight = action.newVal;
                     else if (action.prop === 'color') {
                         if (action.element.classList.contains('shape-box')) action.element.style.borderColor = action.newVal;
                         else if (action.element.classList.contains('shape-line')) action.element.style.backgroundColor = action.newVal;
                         else action.element.style.color = action.newVal;
                    } else if (action.prop === 'size') {
                        action.element.style.fontSize = action.newVal;
                    }
                    break;
            }
        }

        // --- Init ---
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        window.onload = async function() {
            // Restore from DB
            showLoader(true, "Restoring session...");
            try {
                const savedDocs = await loadAllFromDB();
                if(savedDocs && savedDocs.length > 0) {
                    for(const sDoc of savedDocs) {
                         await loadDocumentFromData(sDoc.id, sDoc.name, sDoc.data, sDoc.state);
                    }
                    if(documents.length > 0) setActiveDocument(documents[0].id);
                    else renderTabs();
                } else {
                    renderTabs();
                }
            } catch(e) {
                console.error("Failed to load session", e);
            }
            showLoader(false);
        };

        // --- Event Listeners ---
        document.addEventListener('click', (e) => {
            if(!e.target.closest('.relative')) {
                document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
            }
        });

        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                performUndo();
                return;
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                performRedo();
                return;
            }

            if (document.activeElement && document.activeElement.isContentEditable) return; 
            if(e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
        });

        function handleWorkspaceClick(e) {
            if (e.target.id === 'pdf-workspace' || e.target.classList.contains('pdf-page-container')) {
                deselectAll();
            }
        }

        // --- Tab & Doc Management ---
        function getActiveDoc() { return documents.find(d => d.id === activeDocId); }
        
        function getGuides(pageOverlay) {
            if (!pageOverlay) return { horizontal: [], vertical: [] };
            const guides = Array.from(pageOverlay.querySelectorAll('.guide-line'));
            return {
                horizontal: guides.filter(el => el.classList.contains('guide-horizontal')),
                vertical: guides.filter(el => el.classList.contains('guide-vertical')),
            };
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const data = new Uint8Array(e.target.result);
                    const id = Date.now().toString();
                    await saveFileToDB(id, file.name, data); // Save File
                    loadDocumentFromData(id, file.name, data, null);
                };
                reader.readAsArrayBuffer(file);
            }
            event.target.value = ''; 
        }

        async function loadDocumentFromData(id, name, data, savedState) {
             const newDoc = {
                id: id,
                name: name,
                fileBytes: data,
                renderBytes: new Uint8Array(data), // Clone data for PDF.js to avoid buffer detachment issues
                pdfDoc: null,
                pages: [], 
                scale: savedState ? savedState.scale : 1.0, 
                containerDiv: document.createElement('div'),
                savedState: savedState // Hold for restoration
            };
            newDoc.containerDiv.className = "w-full flex flex-col items-center";
            documents.push(newDoc);
            
            try {
                await renderPDFData(newDoc);
                setActiveDocument(id);
                renderTabs();
            } catch(e) {
                console.error(e);
            }
        }

        async function renderPDFData(docObj) {
            try {
                const loadingTask = pdfjsLib.getDocument({ data: docObj.renderBytes });
                docObj.pdfDoc = await loadingTask.promise;
                docObj.containerDiv.innerHTML = '';
                docObj.pages = [];
                for (let pageNum = 1; pageNum <= docObj.pdfDoc.numPages; pageNum++) {
                    const page = await docObj.pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: docObj.scale });
                    const textContent = await page.getTextContent();
                    
                    const pageContainer = document.createElement('div');
                    pageContainer.className = 'pdf-page-container';
                    pageContainer.style.width = `${viewport.width}px`;
                    pageContainer.style.height = `${viewport.height}px`;
                    pageContainer.dataset.pageNum = pageNum;
                    
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    
                    const overlay = document.createElement('div');
                    overlay.className = 'page-overlay';
                    overlay.id = `overlay-${docObj.id}-${pageNum}`;
                    
                    // Add saved textContent to page object for magic wand
                    docObj.pages.push({ pageNum, viewport, width: viewport.width, height: viewport.height, element: overlay, textContent });
                    
                    // Deselect
                    overlay.addEventListener('mousedown', (e) => {
                        if (e.target === overlay && currentTool === 'cursor') {
                             deselectAll();
                        }
                    });
                    
                    setupOverlayEvents(overlay, docObj);
                    
                    // Restore Elements if state exists
                    if(docObj.savedState && docObj.savedState.pages && docObj.savedState.pages[pageNum]) {
                        docObj.savedState.pages[pageNum].forEach(elData => {
                            const el = document.createElement('div');
                            el.className = elData.classList;
                            Object.assign(el.style, elData.style);
                            el.innerHTML = elData.innerHTML;
                            if(elData.dataset) Object.assign(el.dataset, elData.dataset);
                            
                            // Specific restoration logic
                            if(el.classList.contains('added-text')) {
                                el.contentEditable = true;
                                setupTextEditing(el);
                            }
                            if(el.classList.contains('guide-line')) {
                                // Guides need specific pointers
                                if(el.classList.contains('guide-horizontal')) el.dataset.dragY = 'true';
                                else el.dataset.dragX = 'true';
                            }
                            
                            overlay.appendChild(el);
                            enableDragAndSelect(el);
                        });
                    }

                    pageContainer.appendChild(canvas);
                    pageContainer.appendChild(overlay);
                    docObj.containerDiv.appendChild(pageContainer);
                }
            } catch (err) { console.error(err); throw new Error("Error rendering PDF"); }
        }

        function setActiveDocument(id) {
            deselectAll();
            activeDocId = id;
            const doc = documents.find(d => d.id === id);
            document.getElementById('empty-state').classList.add('hidden');
            document.getElementById('workspace-wrapper').classList.remove('hidden');
            const workspace = document.getElementById('pdf-workspace');
            workspace.innerHTML = ''; 
            workspace.appendChild(doc.containerDiv); 
            document.getElementById('zoom-label').innerText = Math.round(doc.scale * 100) + '%';
            doc.containerDiv.style.transform = `scale(${doc.scale})`;
            renderTabs();
        }

        function closeDocument(e, id) {
            e.stopPropagation();
            deleteDocFromDB(id); // Remove from persistence
            documents = documents.filter(d => d.id !== id);
            if(documents.length === 0) {
                activeDocId = null;
                document.getElementById('empty-state').classList.remove('hidden');
                document.getElementById('workspace-wrapper').classList.add('hidden');
            } else if (activeDocId === id) setActiveDocument(documents[documents.length - 1].id);
            else renderTabs();
        }

        function renderTabs() {
            const bar = document.getElementById('tab-bar');
            bar.innerHTML = '';
            if(documents.length === 0) { bar.innerHTML = '<div class="px-4 py-2 text-sm text-gray-500 italic">No document open</div>'; return; }
            documents.forEach(doc => {
                const isActive = doc.id === activeDocId;
                const tab = document.createElement('div');
                tab.className = `tab-item px-4 py-2 text-sm cursor-pointer flex items-center gap-2 border-r border-gray-300 ${isActive ? 'active' : 'bg-gray-100 text-gray-600 hover:bg-gray-50'}`;
                tab.innerHTML = `<span class="truncate max-w-[120px]">${doc.name}</span><button class="hover:text-red-500 rounded-full p-0.5" onclick="closeDocument(event, '${doc.id}')"><i class="fa-solid fa-xmark"></i></button>`;
                tab.onclick = () => setActiveDocument(doc.id);
                bar.appendChild(tab);
            });
        }

        // --- Tools Logic ---
        function setTool(name) {
            currentTool = name;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            if(name === 'line' || name === 'box') document.getElementById('btn-shape').classList.add('active');
            else if (name === 'guide-h' || name === 'guide-v') document.getElementById('btn-guide').classList.add('active');
            else {
                const btn = document.getElementById(`btn-${name}`);
                if(btn) btn.classList.add('active');
            }
            document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
            const ws = document.getElementById('pdf-workspace');
            
            if (name === 'magic') ws.style.cursor = 'crosshair'; 
            else if (name !== 'cursor') ws.style.cursor = 'crosshair'; 
            else ws.style.cursor = 'default';
            
            document.querySelectorAll('.magic-highlight').forEach(el => el.remove());
            deselectAll();
        }

        function toggleDropdown(id) { document.getElementById(id).classList.toggle('show'); }
        
        // --- Magic Text Feature (Box & Click) ---
        let magicBox = null;
        let magicStart = null;

        function handleMagicHover(e, textContent, viewport, overlay) {
            // Only highlight single items if not dragging
            if (currentTool !== 'magic' || magicStart) return; 
            
            // Remove previous hover highlights
            const existing = overlay.querySelector('.magic-highlight');
            if (existing) existing.remove();
        }

        function handleMagicClick(e, textContent, viewport, overlay) {
           // Click handled in setupOverlayEvents (mousedown/up) now to support dragging
        }

        function processMagicSelection(rect, textContent, viewport, overlay) {
            let matches = [];

            for (const item of textContent.items) {
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                const vx = tx[4];
                const vy = tx[5]; 
                const fontSize = Math.sqrt(tx[2]*tx[2] + tx[3]*tx[3]); 
                const realWidth = item.width * Math.sqrt(tx[0]*tx[0] + tx[1]*tx[1]); 
                
                const tLeft = vx;
                const tTop = vy - fontSize;
                const tRight = vx + realWidth;
                const tBottom = vy;

                // Check Intersection
                const intersects = !(rect.x > tRight || 
                                   (rect.x + rect.w) < tLeft || 
                                   rect.y > tBottom || 
                                   (rect.y + rect.h) < tTop);

                // Add stricter filtering
                if (intersects && item.str.trim().length > 0 && realWidth > 0) {
                    matches.push({
                        str: item.str,
                        x: tLeft,
                        y: tTop,
                        w: realWidth,
                        h: fontSize,
                        r: tRight,
                        b: tBottom
                    });
                }
            }
            
            if (matches.length === 0) return;

            // 1. Calculate Average Font Size
            let avgFontSize = 0;
            matches.forEach(m => avgFontSize += m.h);
            avgFontSize = avgFontSize / matches.length;
            
            // 2. Sort Matches
            matches.sort((a, b) => {
                if (Math.abs(a.y - b.y) > (avgFontSize / 2)) {
                    return a.y - b.y;
                }
                return a.x - b.x;
            });

            // 3. Construct the Combined Text (Reflow Logic)
            let combinedText = "";
            let lastY = matches[0].y;
            let lastX = matches[0].x;

            matches.forEach((m, i) => {
                // Large vertical gap -> New Paragraph
                if (Math.abs(m.y - lastY) > (avgFontSize * 1.5) && i > 0) {
                    combinedText += "\n";
                } 
                // Space Detection (simple approx)
                else if (i > 0) {
                     combinedText += " ";
                }
                
                combinedText += m.str;
                lastY = m.y;
            });


            // --- FIX: Use User Box for dimensions to prevent weird resizing ---
            
            const boxX = rect.x;
            const boxY = rect.y;
            const boxW = rect.w;
            const boxH = rect.h;

            // Determine Background Color
            let bgColor = 'white';
            try {
                // Find canvas sibling (usually previous element)
                const pageContainer = overlay.parentElement;
                const canvas = pageContainer.querySelector('canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    // Sample slightly outside topleft of box (padding area) to find background
                    // Ensure we don't go negative
                    const sampleX = Math.max(0, boxX - 5);
                    const sampleY = Math.max(0, boxY - 5);
                    const p = ctx.getImageData(sampleX, sampleY, 1, 1).data;
                    // Convert to Hex/RGB string
                    bgColor = `rgb(${p[0]}, ${p[1]}, ${p[2]})`;
                }
            } catch(e) {
                console.log("Could not sample background color", e);
            }

            // 1. Create ONE Text Box
            const newText = document.createElement('div');
            newText.className = 'editor-element added-text';
            newText.contentEditable = true;
            newText.style.left = boxX + 'px';
            newText.style.top = boxY + 'px'; 
            newText.style.width = boxW + 'px'; // Enforce drawn width
            newText.style.fontSize = Math.round(avgFontSize) + 'px';
            newText.style.color = '#000000';
            newText.style.whiteSpace = 'normal'; // Allow reflow
            newText.innerText = combinedText;
            
            overlay.appendChild(newText);
            
            // 2. Create ONE Whiteout Box matching drawn box
            const whiteout = document.createElement('div');
            whiteout.className = 'editor-element whiteout-box';
            whiteout.style.left = boxX + 'px';
            whiteout.style.top = boxY + 'px';
            whiteout.style.width = boxW + 'px';
            whiteout.style.height = boxH + 'px';
            whiteout.style.backgroundColor = bgColor; // Apply sampled color
            
            // Insert whiteout BEFORE text so it's behind
            overlay.insertBefore(whiteout, newText);

            setupTextEditing(newText);
            enableDragAndSelect(newText);
            enableDragAndSelect(whiteout);
            
            // Push distinct elements (not grouped)
            pushAction({
                type: 'create',
                elements: [whiteout, newText],
                parent: overlay
            });
        }

        // --- Interaction Logic ---
        function setupOverlayEvents(overlay, docObj) {
            let startX, startY;
            let currentDrawing = null;
            let isMagicDragging = false;

            overlay.addEventListener('mousedown', (e) => {
                if(e.target !== overlay) return;

                startX = e.offsetX;
                startY = e.offsetY;

                if(currentTool.startsWith('guide')) {
                    const el = createGuide(overlay, currentTool === 'guide-h' ? e.offsetY : e.offsetX, currentTool === 'guide-h' ? 'horizontal' : 'vertical');
                    pushAction({ type: 'create', elements: [el], parent: overlay });
                    setTool('cursor');
                    return;
                }
                
                if (currentTool === 'cursor') return; 

                if (currentTool === 'magic') {
                    isMagicDragging = true;
                    magicBox = document.createElement('div');
                    magicBox.className = 'selection-box';
                    magicBox.style.left = startX + 'px';
                    magicBox.style.top = startY + 'px';
                    magicBox.style.width = '0px';
                    magicBox.style.height = '0px';
                    overlay.appendChild(magicBox);
                    return;
                }

                currentDrawing = document.createElement('div');
                currentDrawing.className = 'editor-element';
                currentDrawing.style.left = startX + 'px';
                currentDrawing.style.top = startY + 'px';
                
                if(currentTool === 'whiteout') currentDrawing.classList.add('whiteout-box');
                else if(currentTool === 'box') currentDrawing.classList.add('shape-box');
                else if(currentTool === 'line') {
                    currentDrawing.classList.add('shape-line');
                    currentDrawing.style.height = '1px'; // Changed to 1px
                } else if (currentTool === 'text') {
                    currentDrawing.classList.add('added-text');
                    currentDrawing.contentEditable = true; 
                    currentDrawing.style.fontSize = document.getElementById('font-size').value + 'px';
                    currentDrawing.style.color = document.getElementById('elem-color').value;
                    currentDrawing.innerHTML = 'Type here';
                }

                overlay.appendChild(currentDrawing);
                selectElement(currentDrawing); 
            });

            overlay.addEventListener('mousemove', (e) => {
                const width = e.offsetX - startX;
                const height = e.offsetY - startY;

                if (currentTool === 'magic' && isMagicDragging && magicBox) {
                    const finalWidth = Math.abs(width);
                    const finalHeight = Math.abs(height);
                    magicBox.style.width = finalWidth + 'px';
                    magicBox.style.height = finalHeight + 'px';
                    magicBox.style.left = (width < 0 ? startX - finalWidth : startX) + 'px';
                    magicBox.style.top = (height < 0 ? startY - finalHeight : startY) + 'px';
                    return;
                }

                if(!currentDrawing) return;
                
                const finalWidth = Math.max(MIN_SIZE, Math.abs(width));
                const finalHeight = Math.max(MIN_SIZE, Math.abs(height));

                currentDrawing.style.width = finalWidth + 'px';
                currentDrawing.style.height = finalHeight + 'px';
                currentDrawing.style.left = (width < 0 ? startX - finalWidth : startX) + 'px';
                currentDrawing.style.top = (height < 0 ? startY - finalHeight : startY) + 'px';

                if(currentTool === 'line') {
                    currentDrawing.style.height = '1px'; // Maintain 1px during drag
                    currentDrawing.style.top = startY + 'px';
                }
            });

            overlay.addEventListener('mouseup', () => {
                if (currentTool === 'magic' && magicBox) {
                    // Capture bounds
                    const rect = {
                        x: parseInt(magicBox.style.left),
                        y: parseInt(magicBox.style.top),
                        w: parseInt(magicBox.style.width),
                        h: parseInt(magicBox.style.height)
                    };
                    magicBox.remove();
                    magicBox = null;
                    isMagicDragging = false;
                    
                    // Increased Threshold to 15px to distinguish accidental drags vs box selects
                    const isClick = rect.w < 15 && rect.h < 15;

                    if (isClick) {
                        // Expand rect to act as point click
                         rect.x -= 5; rect.y -= 5; rect.w = 10; rect.h = 10;
                    }

                    // Find text in bounds
                    const pageObj = docObj.pages.find(p => p.element === overlay);
                    if(pageObj) {
                        processMagicSelection(rect, pageObj.textContent, pageObj.viewport, overlay);
                    }
                    return;
                }

                if(currentDrawing) {
                    const el = currentDrawing;
                    
                    // Validation Logic
                    let isValid = true;
                    if(currentTool === 'line') {
                        // For lines, check width (length) only
                        if(el.offsetWidth < 5) isValid = false; // Allow down to 5px
                    } else {
                        // For boxes/text, check both
                        if(el.offsetWidth < MIN_SIZE || el.offsetHeight < MIN_SIZE) isValid = false;
                    }

                    if(!isValid) {
                        el.remove();
                        selectedElement = null; 
                    } else {
                        if(currentTool === 'box') el.style.borderColor = document.getElementById('elem-color').value;
                        else if(currentTool === 'line') el.style.backgroundColor = document.getElementById('elem-color').value;
                        
                        enableDragAndSelect(el);
                        selectElement(el); 
                        
                        pushAction({ type: 'create', elements: [el], parent: overlay });

                        if(currentTool === 'text' && el.isConnected) {
                             setupTextEditing(el);
                             setTimeout(() => {
                                el.focus();
                                el.classList.add('is-editing');
                                document.execCommand('selectAll',false,null);
                            }, 10);
                        }
                    }
                    currentDrawing = null;
                    setTool('cursor'); 
                }
            });
        }
        
        function setupTextEditing(el) {
            el.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                el.focus();
                el.classList.add('is-editing');
            });
            el.addEventListener('blur', () => { 
                el.classList.remove('is-editing');
                // Trigger save on blur
                if(activeDocId) {
                     const doc = getActiveDoc();
                     saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
                }
            });
            el.addEventListener('focus', () => { 
                el.classList.add('is-editing'); 
                checkSelectionState();
            });
            el.addEventListener('input', () => {
                 // Optional: Debounce save here if needed
            });
        }

        function createGuide(parent, pos, type) {
            const el = document.createElement('div');
            el.className = 'editor-element guide-line ' + (type === 'horizontal' ? 'guide-horizontal' : 'guide-vertical');
            if(type === 'horizontal') { el.style.top = pos + 'px'; el.dataset.dragY = 'true'; }
            else { el.style.left = pos + 'px'; el.dataset.dragX = 'true'; }
            parent.appendChild(el);
            enableDragAndSelect(el);
            selectElement(el);
            return el;
        }

        function enableDragAndSelect(el) {
            let isDragging = false;
            let offset = [0,0];
            let startState = null;

            function isEditing() { return el.classList.contains('added-text') && el.classList.contains('is-editing'); }

            el.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) return;
                
                if (isEditing() || (currentTool !== 'cursor' && !el.classList.contains('guide-line'))) { 
                    return; 
                }
                
                e.stopPropagation(); 
                e.preventDefault(); 
                
                selectElement(el);
                
                isDragging = true;
                el.style.cursor = 'grabbing';
                offset = [el.offsetLeft - e.clientX, el.offsetTop - e.clientY];
                
                startState = { 
                    left: el.style.left, top: el.style.top, 
                    width: el.style.width, height: el.style.height 
                };
            }); 
            
            document.addEventListener('mouseup', () => {
                if(isDragging) {
                    isDragging = false;
                    if(el.classList.contains('guide-horizontal')) el.style.cursor = 'ns-resize';
                    else if(el.classList.contains('guide-vertical')) el.style.cursor = 'ew-resize';
                    else if(!isEditing()) el.style.cursor = 'move';
                    
                    if (startState && (el.style.left !== startState.left || el.style.top !== startState.top)) {
                        pushAction({
                            type: 'move_resize',
                            element: el,
                            start: startState,
                            end: { left: el.style.left, top: el.style.top, width: el.style.width, height: el.style.height }
                        });
                    }
                    startState = null;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if(!isDragging) return;
                e.preventDefault();
                let newLeft = e.clientX + offset[0];
                let newTop = e.clientY + offset[1];
                
                // Snapping Logic
                const overlay = el.closest('.page-overlay');
                if (overlay && currentTool === 'cursor') {
                    const guides = getGuides(overlay);
                    let snappedX = false;
                    let snappedY = false;

                    // Vertical Guides (Snap X)
                    guides.vertical.forEach(g => {
                        const gx = parseFloat(g.style.left);
                        // Snap left edge
                        if (Math.abs(newLeft - gx) < SNAP_THRESHOLD) {
                            newLeft = gx; snappedX = true;
                        }
                        // Snap right edge
                        else if (Math.abs((newLeft + el.offsetWidth) - gx) < SNAP_THRESHOLD) {
                            newLeft = gx - el.offsetWidth; snappedX = true;
                        }
                    });

                    // Horizontal Guides (Snap Y)
                    guides.horizontal.forEach(g => {
                        const gy = parseFloat(g.style.top);
                        // Snap top edge
                        if (Math.abs(newTop - gy) < SNAP_THRESHOLD) {
                            newTop = gy; snappedY = true;
                        }
                        // Snap bottom edge
                        else if (Math.abs((newTop + el.offsetHeight) - gy) < SNAP_THRESHOLD) {
                            newTop = gy - el.offsetHeight; snappedY = true;
                        }
                    });
                }
                
                if (el.dataset.dragY) el.style.top = newTop + 'px';
                else if (el.dataset.dragX) el.style.left = newLeft + 'px';
                else { el.style.left = newLeft + 'px'; el.style.top = newTop + 'px'; }
            });
        }

        function addResizingHandles(el) {
            // No handles for guides
            if(el.classList.contains('guide-line')) return;

            el.querySelectorAll('.resize-handle').forEach(h => h.remove());
            ['tl', 'tr', 'bl', 'br'].forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos} w-3 h-3 bg-blue-500 border border-white rounded-full absolute z-50`;
                if(pos.includes('t')) handle.style.top = '-6px';
                if(pos.includes('b')) handle.style.bottom = '-6px';
                if(pos.includes('l')) handle.style.left = '-6px';
                if(pos.includes('r')) handle.style.right = '-6px';
                handle.style.cursor = (pos==='tl'||pos==='br') ? 'nwse-resize' : 'nesw-resize';
                handle.dataset.position = pos;
                el.appendChild(handle);
                handle.addEventListener('mousedown', startResize);
            });
        }

        let isResizing=false, resizeHandle=null, resizeEl=null, rStart={}, rStartState=null;
        function startResize(e) {
            e.stopPropagation();
            isResizing = true;
            resizeHandle = e.target;
            resizeEl = resizeHandle.closest('.editor-element');
            rStart = { x: e.clientX, y: e.clientY, w: resizeEl.offsetWidth, h: resizeEl.offsetHeight, l: resizeEl.offsetLeft, t: resizeEl.offsetTop };
            rStartState = { left: resizeEl.style.left, top: resizeEl.style.top, width: resizeEl.style.width, height: resizeEl.style.height };
            document.addEventListener('mousemove', duringResize);
            document.addEventListener('mouseup', endResize);
        }
        function duringResize(e) {
            if(!isResizing) return;
            e.preventDefault();
            const dx = e.clientX - rStart.x;
            const dy = e.clientY - rStart.y;
            const p = resizeHandle.dataset.position;
            let nw = rStart.w, nh = rStart.h, nl = rStart.l, nt = rStart.t;

            if(p.includes('l')) { nw -= dx; if(nw >= MIN_SIZE) nl += dx; else nw = MIN_SIZE; }
            else if(p.includes('r')) { nw += dx; nw = Math.max(MIN_SIZE, nw); }
            
            if(p.includes('t')) { nh -= dy; if(nh >= MIN_SIZE) nt += dy; else nh = MIN_SIZE; }
            else if(p.includes('b')) { nh += dy; nh = Math.max(MIN_SIZE, nh); }

            resizeEl.style.width = nw + 'px';
            resizeEl.style.height = nh + 'px';
            if(p.includes('l')) resizeEl.style.left = nl + 'px';
            if(p.includes('t')) resizeEl.style.top = nt + 'px';
        }
        function endResize() {
            if (isResizing && rStartState) {
                pushAction({
                    type: 'move_resize',
                    element: resizeEl,
                    start: rStartState,
                    end: { left: resizeEl.style.left, top: resizeEl.style.top, width: resizeEl.style.width, height: resizeEl.style.height }
                });
            }
            isResizing = false;
            document.removeEventListener('mousemove', duringResize);
            document.removeEventListener('mouseup', endResize);
        }

        function selectElement(el) {
            if (selectedElement && selectedElement !== el) deselectAll();
            selectedElement = el;
            el.classList.add('selected');
            // Ensure handles are created if missing
            if (!el.querySelector('.resize-handle')) addResizingHandles(el);
            
            if(el.classList.contains('added-text')) checkSelectionState();
        }

        function deselectAll() {
            if (selectedElement) {
                selectedElement.classList.remove('selected');
                selectedElement.classList.remove('is-editing');
                if(selectedElement.blur) selectedElement.blur();
            }
            selectedElement = null;
        }

        // --- Helpers ---
        function checkSelectionState() {
            if (!selectedElement || !selectedElement.classList.contains('added-text')) return;
            const isBold = document.queryCommandState('bold');
            if(isBold) document.getElementById('btn-bold').classList.add('bg-gray-200');
            else document.getElementById('btn-bold').classList.remove('bg-gray-200');
        }

        function saveSelection() {
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                if (selectedElement && selectedElement.contains(range.commonAncestorContainer)) {
                     savedRange = range;
                }
            }
        }
        function restoreSelection() {
            if (savedRange && selectedElement) {
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(savedRange);
            }
        }
        
        function toggleBold() {
            if (!selectedElement) return;
            
            if (selectedElement.classList.contains('added-text')) {
                if (selectedElement.classList.contains('is-editing')) {
                     selectedElement.focus();
                     restoreSelection();
                     document.execCommand('bold', false, null);
                } else {
                    const current = selectedElement.style.fontWeight;
                    selectedElement.style.fontWeight = (current === 'bold' || parseInt(current) >= 700) ? 'normal' : 'bold';
                     pushAction({
                        type: 'style',
                        element: selectedElement,
                        prop: 'bold',
                        oldVal: current,
                        newVal: selectedElement.style.fontWeight
                    });
                }
                checkSelectionState();
            }
        }
        
        function updateSelectedProp(type) {
            if(!selectedElement) return;
            const val = type === 'size' ? document.getElementById('font-size').value : document.getElementById('elem-color').value;
            const oldVal = (type === 'size') ? selectedElement.style.fontSize : selectedElement.style.color; 
            
            if(selectedElement.classList.contains('added-text')) {
                if (selectedElement.classList.contains('is-editing')) {
                    selectedElement.focus();
                    restoreSelection();
                    if (type === 'color') document.execCommand('foreColor', false, val);
                    else if (type === 'size') {
                        document.execCommand('fontSize', false, "7");
                        const fonts = selectedElement.querySelectorAll('font[size="7"]');
                        fonts.forEach(f => { f.removeAttribute("size"); f.style.fontSize = val + "px"; });
                    }
                } else {
                    if(type === 'color') selectedElement.style.color = val;
                    if(type === 'size') selectedElement.style.fontSize = val + 'px';
                }
            } else {
                if(type === 'color') {
                    if(selectedElement.classList.contains('shape-box')) selectedElement.style.borderColor = val;
                    else if(selectedElement.classList.contains('shape-line')) selectedElement.style.backgroundColor = val;
                }
            }
            
             pushAction({
                type: 'style',
                element: selectedElement,
                prop: type,
                oldVal: oldVal,
                newVal: val
            });
        }
        
        function deleteSelected() {
            if(selectedElement && !selectedElement.classList.contains('is-editing')) {
                const parent = selectedElement.parentElement;
                pushAction({ type: 'delete', elements: [selectedElement], parent: parent });
                selectedElement.remove();
                selectedElement = null;
            }
        }

        function rgbToHex(col) {
            if(!col) return '#000000';
            if(col.startsWith('#')) return col;
            const rgb = col.match(/\d+/g);
            if(!rgb) return '#000000';
            return "#" + ("0"+parseInt(rgb[0],10).toString(16)).slice(-2) + ("0"+parseInt(rgb[1],10).toString(16)).slice(-2) + ("0"+parseInt(rgb[2],10).toString(16)).slice(-2);
        }

        // --- NEW: Parse Color Robustly (Handles RGB and Hex) ---
        function parseColorString(colorStr) {
            if (!colorStr) return { r: 0, g: 0, b: 0 };
            
            // Handle RGB/RGBA
            if (colorStr.trim().startsWith('rgb')) {
                const parts = colorStr.match(/\d+/g);
                if (parts && parts.length >= 3) {
                    return { r: parseInt(parts[0]), g: parseInt(parts[1]), b: parseInt(parts[2]) };
                }
            }
            
            // Handle Hex
            if (colorStr.startsWith('#')) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(colorStr);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }
            
            return { r: 0, g: 0, b: 0 }; // Default to black
        }

        // Renamed wrapper for backward compat if needed, but updated logic below
        function hexToRgb(hex) {
           return parseColorString(hex);
        }

        function changeZoom(delta) {
            if(!activeDocId) return;
            const doc = getActiveDoc();
            doc.scale = parseFloat((doc.scale + delta).toFixed(1));
            if(doc.scale < 0.5) doc.scale = 0.5;
            if(doc.scale > 3.0) doc.scale = 3.0;
            doc.containerDiv.style.transform = `scale(${doc.scale})`;
            document.getElementById('zoom-label').innerText = Math.round(doc.scale * 100) + '%';
            // Save state on zoom change (scale persistence)
            saveStateToDB(doc.id, serializeDocState(doc), doc.scale);
        }

        function extractTextSegments(node, currentStyle) {
            const segments = [];
            if (node.nodeType === Node.TEXT_NODE) {
                if (node.nodeValue.length > 0) { 
                    segments.push({ text: node.nodeValue, style: { ...currentStyle } });
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const newStyle = { ...currentStyle };
                const s = window.getComputedStyle(node);
                if (s.fontWeight === 'bold' || parseInt(s.fontWeight) >= 700 || node.tagName === 'B' || node.tagName === 'STRONG') newStyle.isBold = true;
                if (s.color) newStyle.color = rgbToHex(s.color);
                if (s.fontSize) newStyle.fontSize = parseFloat(s.fontSize);
                node.childNodes.forEach(child => {
                    segments.push(...extractTextSegments(child, newStyle));
                });
            }
            return segments;
        }

        async function saveCurrentDoc() {
            if(!activeDocId) return;
            const doc = getActiveDoc();
            showLoader(true, "Generating PDF...");
            try {
                const pdfDocLib = await PDFLib.PDFDocument.load(doc.fileBytes);
                const standardFont = await pdfDocLib.embedFont(PDFLib.StandardFonts.Helvetica);
                const boldFont = await pdfDocLib.embedFont(PDFLib.StandardFonts.HelveticaBold);
                const pages = pdfDocLib.getPages();
                doc.pages.forEach((p, index) => {
                    const pdfPage = pages[index];
                    const { width, height } = pdfPage.getSize(); 
                    const scale = doc.scale; 
                    const elements = Array.from(p.element.children).filter(el => el.classList.contains('editor-element'));
                    elements.forEach(el => {
                        if(el.classList.contains('guide-line')) return;
                        const style = window.getComputedStyle(el);
                        const left = parseFloat(style.left) / scale; 
                        const top = parseFloat(style.top) / scale;
                        const elWidth = parseFloat(style.width) / scale;
                        const elHeight = parseFloat(style.height) / scale;
                        if(el.classList.contains('added-text')) {
                            const baseFontSize = parseFloat(style.fontSize) / scale;
                            const baseColor = rgbToHex(style.color);
                            const segments = extractTextSegments(el, { 
                                isBold: (style.fontWeight === 'bold' || parseInt(style.fontWeight) >= 700), 
                                color: baseColor, 
                                fontSize: baseFontSize 
                            });
                            let cursorX = left;
                            let cursorY = height - top - baseFontSize + (baseFontSize * 0.2); 
                            let currentLineHeight = baseFontSize * 1.2;
                            segments.forEach(seg => {
                                const font = seg.style.isBold ? boldFont : standardFont;
                                const fontSize = (seg.style.fontSize) ? (seg.style.fontSize / scale) : baseFontSize;
                                const rgb = parseColorString(seg.style.color);
                                const color = PDFLib.rgb(rgb.r/255, rgb.g/255, rgb.b/255);
                                const words = seg.text.split(/(\s+)/); 
                                words.forEach(word => {
                                    const widthOfWord = font.widthOfTextAtSize(word, fontSize);
                                    if (cursorX + widthOfWord > left + elWidth && cursorX > left) {
                                        cursorX = left;
                                        cursorY -= currentLineHeight;
                                    }
                                    pdfPage.drawText(word, { x: cursorX, y: cursorY, size: fontSize, font: font, color: color });
                                    cursorX += widthOfWord;
                                });
                            });
                        } else {
                            // Logic Updated Here
                            const rgb = parseColorString(el.style.backgroundColor || el.style.borderColor || '#000000');
                            const pdfColor = PDFLib.rgb(rgb.r/255, rgb.g/255, rgb.b/255);
                            
                            const pdfY = height - top - elHeight;
                            if (el.classList.contains('whiteout-box')) {
                                pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, color: pdfColor, borderOpacity: 0 });
                            } else if (el.classList.contains('shape-line')) {
                                pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, color: pdfColor });
                            } else if (el.classList.contains('shape-box')) {
                                const borderRgb = parseColorString(el.style.borderColor || '#000000');
                                const borderPdfColor = PDFLib.rgb(borderRgb.r/255, borderRgb.g/255, borderRgb.b/255);
                                pdfPage.drawRectangle({ x: left, y: pdfY, width: elWidth, height: elHeight, borderColor: borderPdfColor, borderWidth: 2/scale, opacity: 0 });
                            }
                        }
                    });
                });
                const pdfBytes = await pdfDocLib.save();
                downloadBlob(pdfBytes, "edited_" + doc.name);
            } catch(e) { console.error(e); console.error("Save failed."); } finally { showLoader(false); }
        }

        function downloadBlob(data, fileName) {
            const blob = new Blob([data], { type: "application/pdf" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function showLoader(show, text = "Processing...") {
            const l = document.getElementById('loader-overlay');
            document.getElementById('loader-text').innerText = text;
            if(show) l.classList.remove('hidden');
            else l.classList.add('hidden');
        }
    </script>
</body>
</html>